<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Weihang Lo</title><link>https://weihanglo.tw/tags/algorithms/</link><description>Recent content in Algorithms on Weihang Lo</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 28 Aug 2020 00:00:00 +0800</lastBuildDate><atom:link href="https://weihanglo.tw/tags/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>布隆過濾器 Bloom Filter</title><link>https://weihanglo.tw/posts/2020/bloom-filter/</link><pubDate>Fri, 28 Aug 2020 00:00:00 +0800</pubDate><guid>https://weihanglo.tw/posts/2020/bloom-filter/</guid><description>本篇從 Rust Algorithm Club 移植，若欲閱讀最新版，請移駕至Rust 演算法俱樂部：布隆過濾器 Bloom Filter 一文，此文不同步更新。
Bloom filter 是一種機率資料結構（probabilistic data structure），類似於集合，常用於需快速驗證成員是否「可能存在」或是「絕對不存在」在容器中，亦即有機會出現假陽性（false positive），但絕不會有假陰性（false negative）。
Bloom filter 的優勢是：
類似集合，可在 $O(1)$ 時間複雜度驗證成員是否存在，卻僅需相對少的儲存空間。 承上，在 0.1% 錯誤率下儲存一百萬個元素僅需 1.71 MiB。 非常容易實作的機率資料結構，僅需多次雜湊。 Bloom filter 則有以下短處：
經典款 Bloom filter 容器大小固定（fixed-size），無法動態調整儲存空間。 可能給出假陽性答案：回報存在但實際不存在，且錯誤隨數量變多上升。 自身不儲存成員資料，需要有額外的儲存資料方案。 只能新增成員，但不能移除成員（可透過變形解決）。 若輸入資料集本身離散，接近隨機存取，無法充分利用 CPU cache。 承上，因為隨機存取，不利於延伸到記憶體以外的外部儲存裝置。 Bloom filter 常見應用場景為：
資料庫利用 Bloom filter 中減少實際存取 disk 的 IO 開銷。 Chromium 瀏覽器驗證大量惡意連結。 Medium 避免推薦已推薦過的文章。 小知識：bloom 是開花之意，但 Bloom filter 和開花沒任何關係，只因發明人姓氏為 Bloom</description></item><item><title>漸進符號 Asymptotic Notation</title><link>https://weihanglo.tw/posts/2018/asymptotic-notation/</link><pubDate>Thu, 31 May 2018 23:38:59 +0800</pubDate><guid>https://weihanglo.tw/posts/2018/asymptotic-notation/</guid><description>這是個人第一次撰寫 CS 基礎知識的文章，同時也是 Rust Algorithm Club 基礎概念的首篇文章，目前 Rust Algorithm Club 尚未完工，請各位敬請期待。
（撰於 2018-05-31）
日常生活中，你會如何描述處理事情的效率？
「原來她五分鐘內可以吃掉一頭牛！」
「房間這麼小你還能擺一堆雜物？還不快收拾！」
這些描述方法，著重在處理事情的花費時間，或單位空間內的儲存量。描述演算法的效率也如此，就是「測量演算法的執行成本」，例如這個排序法花了 10 秒鐘跑完兩萬筆資料，或是這個模擬演算法很吃資源需要 32 GB 的記憶體。
然而，在不同的機器規格、環境溫濕度、程式語言、實作方式，以及有沒有放乖乖的變異影響下，相同演算法的執行成本常常不一致。為了消弭這些外部因素，讓分析演算法能夠更科學化。科學家抽絲剝繭，發明一個方法：
「統計演算法內所需操作步驟的數目。」
這是最簡單，最粗淺比較不同演算法效率的作法。
用數學表示演算法效率 「計算步驟數目」很像中小學的數學題目：某公司有三個能力相異的工程師，有的工程師一天解決一個 bug，有的工程師連續工作後效率大幅滑落。每個工程師的除蟲效率可以畫成「bug 數 - 解決 bug 所需時數」函數，橫軸為待處理的臭蟲數，縱軸為解決臭蟲所需時數，如圖一與表所示。
時數 \(\log N\) \(N\) \(N \log N\) \(N=5\) 2.236 5 8.046 \(N=30\) 5.477 30 102.036 不論從圖或表，我們都可以明確看出，當 bug 數目小時，每個工程師耗時差不多；當 bug 數目成長到一定程度時，效率好與效率差的工程師差距就很明顯了。
我們把場景拉回演算法的範疇，再闡明一次。上述的除蟲效率函數關係，可以簡單視為為「輸入資料量 - 運算成本」關係之函數。例如 \(f(x)=x^2+3x+6\)。當輸入資料量增大時，成本也隨之上升，這個用來描述演算法執行成本與輸入資料量之關係的函數，我們稱之為該演算法的「複雜度」。</description></item></channel></rss>