<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Weihang Lo</title>
    <link>https://weihanglo.tw/tags/rust/</link>
    <description>Recent content in Rust on Weihang Lo</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 30 Sep 2018 11:07:45 +0800</lastBuildDate>
    
	<atom:link href="https://weihanglo.tw/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rust: Ownership and References</title>
      <link>https://weihanglo.tw/posts/2018/rust-ownership-and-references/</link>
      <pubDate>Sun, 30 Sep 2018 11:07:45 +0800</pubDate>
      
      <guid>https://weihanglo.tw/posts/2018/rust-ownership-and-references/</guid>
      <description>This is a series of quick notes about the fundamentals of the Rust programming language. It would cover parts of basic concepts and patterns in Rust. As a Rust begineer and a non-native English speaker, I may make some silly mistakes in my notes. Please contact me if there are some misleading words.
(written on 2018-09-30)
Ownership and References While a program runs, it need a way to manage memory .</description>
    </item>
    
    <item>
      <title>【譯】Rust vs. Go</title>
      <link>https://weihanglo.tw/posts/2018/rust-vs-go/</link>
      <pubDate>Fri, 20 Jul 2018 10:58:59 +0800</pubDate>
      
      <guid>https://weihanglo.tw/posts/2018/rust-vs-go/</guid>
      <description>本文譯自 Julio Merino 的 Rust vs. Go。Julio Merino 目前是 G 社僱員，在 G 社工作超過 8 年，無論工作內外，都接觸開發不少 Go 語言，並撰寫 Rust 點評系列文，來聽聽他對 Rust 與 Go 的想法吧。
Thanks Julio Merino for this awesome article!
 歡迎來到「Rust 點評」系列特別篇，也是我在系列文開始就承諾撰寫的主題，將探討一個難以忽視的大哉問：Rust 與 Go 孰優孰劣？
這麼比較並沒有根據，所以不會有標準答案。我認為人們會把這兩種語言作伙比較只因為它們幾乎同時釋出，而且 Rust 的釋出像是在回應 Go。除此之外，兩種語言都被認為聚焦在系統軟體上（system software），但其實它們大相徑庭，就算都專注系統軟體，各自目標的軟體類型也不盡相同。
Go 可以視為「做對了的 C」或是「Python 的替代品」。Go 在開發網路伺服器與自動化工具的領域發光發熱。Rust 專注在正確與安全性，定位在 C++ 與 Haskell 之間，如同之前提及，可以視為「務實的 Haskell」。儘管 Rust 的語言抽象程度很高，它仍承諾這些抽象是零成本（zero-cost abstraction），也就是說，它應該擅長寫任何系統專案。
這篇個人點評基於我用兩種語言寫了相同的專案 sandboxfs。最初實作是用 Go，而我開發了另一個用 Rust 的實驗性改寫（還沒有完全檢驗），兩個實作都通過相同的測試套件（test suite）。除了透過這次改寫來學習語言，也因為當我分析 Go 實作版本的效能時，發現熱點總是在 Go 的執行環境（runtime），我想要嘗試看看簡單的 Rust 改寫後效能能否長進，而情況似乎就是如此。隨著這次改寫，我很訝異原本的 Go 實作版本有不少潛在的並行（concurrency）漏洞，因為許多 Rust 並不允許我利用相同的設計改寫。</description>
    </item>
    
    <item>
      <title>【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架</title>
      <link>https://weihanglo.tw/posts/2018/tokio-internals/</link>
      <pubDate>Fri, 05 Jan 2018 08:44:43 +0800</pubDate>
      
      <guid>https://weihanglo.tw/posts/2018/tokio-internals/</guid>
      <description>本文譯自 Tokio internals: Understanding Rust&amp;rsquo;s asynchronous I/O framework from the bottom up。
Thanks David Simmons for this awesome article!
 Tokio 是 Rust 的開發框架，用於開發非同步 I/O 程式（asynchronous I/O，一種事件驅動的作法，可實現比傳統同步 I/O 更好的延伸性、效能與資源利用）。可惜的是，Tokio 過於精密的抽象設計，招致難以學習的惡名。即使我讀完教程後，依然不認為自己充分內化這些抽象層，以便推斷實際發生的事情。
從前的非同步 I/O 相關開發經驗甚至阻礙我學習 Tokio。我習慣使用作業系統提供的 selection 工具（例如 Linux epoll）當作起點，再轉移至 dispatch、state machine 等等。倘若直接從 Tokio 抽象層出發，卻沒有清楚了解 epoll_wait() 在何處及如何發生，我會覺得難以連結每個概念。Tokio 與 future-driven 的方法就好像一個黑盒子。
我決定不繼續由上而下的方法學習 Tokio，反其道而行，而是透過閱讀原始碼，確切理解具體實作是如何驅動從 epoll 事件到 Future::poll() 消耗 I/O 的整個過程。我不會深入高層次的 Tokio 與 futures 使用細節，現有的教程 有更完整詳細的內容。除了簡短的小結，我也不會探討一般性的非同步 I/O 問題，畢竟這些問題都可寫個獨立的主題了。我的目標是有信心讓 futures 與 Tokio 以我所認知的方式執行。</description>
    </item>
    
  </channel>
</rss>