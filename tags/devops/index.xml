<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DevOps on Weihang Lo</title>
    <link>https://weihanglo.tw/tags/devops/</link>
    <description>Recent content in DevOps on Weihang Lo</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 23 Mar 2020 00:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://weihanglo.tw/tags/devops/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kuberenetes Autoscaling 相關知識小整理</title>
      <link>https://weihanglo.tw/posts/2020/k8s-autoscaling/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://weihanglo.tw/posts/2020/k8s-autoscaling/</guid>
      <description>K8s 有好用的 autoscaling 功能，但你知道除了 pod 之外，node 也可以 auto scaling 嗎？帥，你知道就不用分享了啊 🚬
本文以重點整理的方式，先介紹目前常見的 Autoscaler，再介紹一些防止 pod 被亂殺的 config。
（撰於 2020-03-23，基於 Kubernetes 1.17，但 Api Versions 太多請自行查閱手冊）
讓我們歡迎第一位 Autoscaler 出場！
Cluster Autoscaler（CA） 負責調整 node-pool 的 node size scaling，屬於 cluster level autoscaler。
 白話文：開新機器，關沒路用的機器 😈
  Scale-up： 有 pod 的狀態是 unschedulable 時 Scale-down： 觀察 pod 總共的 memory/CPU request 是否 &amp;lt; 50%（非真實的 resource utilization）+ 沒有其他 pod/node 的條件限制 可設定 min/maxi poolsize（GKE），自己管理的叢集可以設定更多參數 會參照 PriorityClass 來調控 pod，但就是僅僅設立一條貧窮截止線，當前是 -10 ，autoscaler 不會因為低於此線的 pod 而去 scale-up，需要 scale-down 也不會理會 node 裡面是否有這種 pod 部分設定設不好會讓 CA 沒辦法 scaling  CA 要關 node 然後 evict pod 時違反 pod affinity/anti-affinity 和 PodDisruptionBudget 在 node 加上 annotation 可防止被 scale down：&amp;quot;cluster-autoscaler.</description>
    </item>
    
    <item>
      <title>WWW 0x02: Distroless Docker for distressed human</title>
      <link>https://weihanglo.tw/posts/2020/www-0x02/</link>
      <pubDate>Sat, 01 Feb 2020 00:00:11 +0800</pubDate>
      
      <guid>https://weihanglo.tw/posts/2020/www-0x02/</guid>
      <description>這裡是 WWW 第貳期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
How to Review a Pull Request 這份是 Rust 的 crates.io（類似 PyPI 和 rubygems）如何審閱拉取請求的文件， 和 Google 那份不太一樣，更貼近專案一點，節錄重點：
 先拉到自己的本地分支，看看 PR 是否達到他宣稱的療效（檢查一般行為） 嘗試用各種手段打爆他（檢查 edge case） 如果有任何失敗，請寫清楚重新產生錯誤的流程 再來就是理解這個修改到底合不合理，是不是其實不需要  這篇 review guideline 短短的，剩下的自己看囉。
Distroless Docker: Containerizing Apps, not VMs - Matthew Moore 本文是 Google 雇員介紹 Distroless Image 演講的重點摘要，對容器化和 Docker 最佳化有興趣的朋友千萬別錯過。
 Distroless GitHub Repo 在此
 Q：何謂 Distroless Image
Distroless 的 distro 是指 Linux 發行版（distro），加了一個 less 就是替 docker image 瘦身，只留 app source 和 runtime 需要的 dependencies，把發行版中不必要的東西都幹掉。</description>
    </item>
    
    <item>
      <title>WWW 0x01: 有個部署「部署「部署 K8s 」」的工具</title>
      <link>https://weihanglo.tw/posts/2020/www-0x01/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:11 +0800</pubDate>
      
      <guid>https://weihanglo.tw/posts/2020/www-0x01/</guid>
      <description>這裡是 WWW 第壹期，Wow Weihang Weekly 是一個毫無章法的個人週刊，出刊週期極不固定，從一週到五年都有可能。初期內容以軟體工程為主，等財富自由後會有更多雜食篇章。
How to Adopt Modern C++17 into Your C++ Code : Build 2018 推個 C++ 影片，微軟的大師 Herb Sutter 很精要地講完重要的 modern feature 除了 smart pointer，還包含了
 move semantic string_view optional any_cast/variant RAII scoped lifetime 心法 =&amp;gt; Rust 已經是 NLL 了  Tanka：Grafana Lab 部署 k8s 的新工具 Tanka 是 Grafana Lab 開源的新部署工具，原文短又清楚，但這邊還是再疊床架屋摘要一次
 YAML 不是動態語言，很多邏輯會不斷重複，不好寫 Helm 很棒，但奠基在 string template 上仍然難寫難維護，彈性不夠高，Chart 維護者沒 export 的欄位你也不能擅自修改 Helm 其實完全沒有抽象化，就算 values.yaml 挖了很多洞，開發者仍然要去看 template 裡面到底做了什麼事  這些的確都是用 Helm 部署的痛點，尤其是低度抽象化，看看精美的 stable/prometheus-operator，就會開始思考 Helm 的定位與其說是 Package manager，倒像只是一堆 yaml 的集合（事實上就是），完全沒有封裝感，更別提 Resource 修改時，很常遇到 Helm 沒辦法正確更新的痛了。</description>
    </item>
    
  </channel>
</rss>