<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="Front End Development Toolchain"/>




  <meta name="keywords" content="NodeJS,JavaScript,Front-End," />




  <link rel="alternate" href="/atom.xml" title="Weihang Lo">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.2.x" />



<link rel="canonical" href="https://weihanglo.github.io/2017/fed-toolchain/"/>


<meta name="description" content="在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具的使用等等，都是一門學問。本文將從建置基本的前端開發環境起頭，簡單介紹個人愛用現代常用的前端開發工具。
（撰於 2017-03-10）">
<meta property="og:type" content="article">
<meta property="og:title" content="Front End Development Toolchain">
<meta property="og:url" content="https://weihanglo.github.io/2017/fed-toolchain/index.html">
<meta property="og:site_name" content="Weihang Lo">
<meta property="og:description" content="在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具的使用等等，都是一門學問。本文將從建置基本的前端開發環境起頭，簡單介紹個人愛用現代常用的前端開發工具。
（撰於 2017-03-10）">
<meta property="og:image" content="https://leanpub.com/site_images/reactspeedcoding/tech-stack-w820.jpg">
<meta property="og:updated_time" content="2017-04-10T08:50:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Front End Development Toolchain">
<meta name="twitter:description" content="在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具的使用等等，都是一門學問。本文將從建置基本的前端開發環境起頭，簡單介紹個人愛用現代常用的前端開發工具。
（撰於 2017-03-10）">
<meta name="twitter:image" content="https://leanpub.com/site_images/reactspeedcoding/tech-stack-w820.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.2.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: true,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-90000579-1', 'auto');
        ga('send', 'pageview');
  </script>



    <title> Front End Development Toolchain · Weihang Lo </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Weihang Lo</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags/">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Weihang Lo</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            
            
              Tags
            
          </a>
        </li>
      
      
        <li class="menu-search">
          <form>
            <i class="iconfont icon-search" id="open-search"></i>
            <input type="text" class="search-input" id="search-input" />
            <i class="iconfont icon-close" id="close-search"></i>
          </form>
        </li>
      
    </ul>
  
</nav>
      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Front End Development Toolchain
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Mar 10, 2017
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Contents"><span class="toc-text">Contents</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-js"><span class="toc-text">Node.js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安裝-Node-js"><span class="toc-text">安裝 Node.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-js-內建模組、變數"><span class="toc-text">Node.js 內建模組、變數</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-js-版本管理工具"><span class="toc-text">Node.js 版本管理工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NPM-套件模組管理工具"><span class="toc-text">NPM 套件模組管理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#package-json"><span class="toc-text">package.json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NPM-常用指令"><span class="toc-text">NPM 常用指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#預處理器／轉譯器"><span class="toc-text">預處理器／轉譯器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-預處理器"><span class="toc-text">CSS 預處理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-後處理器"><span class="toc-text">CSS 後處理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6-／Babel"><span class="toc-text">ES6+／Babel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自動化工具／打包工具"><span class="toc-text">自動化工具／打包工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gulp"><span class="toc-text">Gulp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack"><span class="toc-text">Webpack</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程式碼品質"><span class="toc-text">程式碼品質</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#測試"><span class="toc-text">測試</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#靜態程式語法檢查"><span class="toc-text">靜態程式語法檢查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小結"><span class="toc-text">小結</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p><img src="https://leanpub.com/site_images/reactspeedcoding/tech-stack-w820.jpg" alt="React Tech Stack"></p>
<p>在大前端的時代，開發 Web app 不再像以前使用一個 jQuery 的 CDN 這麼容易，從 html 模板的抉擇，css 預處理器的挑選，Javascript 模組化的方法，自動化工具的使用等等，都是一門學問。本文將從建置基本的前端開發環境起頭，簡單介紹<del>個人愛用</del>現代常用的前端開發工具。</p>
<p><em>（撰於 2017-03-10）</em></p>
<a id="more"></a>
<h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul>
<li><a href="#Node-js">Node.js</a><ul>
<li><a href="#安裝-Node-js">安裝 Node.js</a></li>
<li><a href="#Node-js-內建模組、變數">Node.js 內建模組、變數</a></li>
<li><a href="#Node-js-版本管理工具">Node.js 版本管理工具</a></li>
</ul>
</li>
<li><a href="#NPM-套件模組管理工具">NPM 套件模組管理工具</a><ul>
<li><a href="#package-json">package.json</a></li>
<li><a href="#NPM-常用指令">NPM 常用指令</a></li>
</ul>
</li>
<li><a href="#預處理器／轉譯器">預處理器／轉譯器</a><ul>
<li><a href="#CSS-預處理器">CSS 預處理器</a></li>
<li><a href="#CSS-後處理器">CSS 後處理器</a></li>
<li><a href="#ES6-／Babel">ES6+／Babel</a></li>
</ul>
</li>
<li><a href="#自動化工具／打包工具">自動化工具／打包工具</a><ul>
<li><a href="#Gulp">Gulp</a></li>
<li><a href="#Webpack">Webpack</a></li>
</ul>
</li>
<li><a href="#程式碼品質">程式碼品質</a><ul>
<li><a href="#測試">測試</a></li>
<li><a href="#靜態程式語法檢查">靜態程式語法檢查</a></li>
</ul>
</li>
<li><a href="#小結">小結</a></li>
<li><a href="#Reference">Reference</a></li>
</ul>
<p>（以下環境皆以 macOS 為例）</p>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p><a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a> 是一個 Javascript 的運行環境，基於 Google V8 Engine。在 Node.js 尚未出現前，Javascript 只能運行在瀏覽器客戶端，功能受限於瀏覽器沙盒（sandbox）與廠商實作。Node.js 推出後，Javascript 程式碼可以在伺服器端運行，模組（module）和套件（package）的觀念和生態圈也隨之建立。程式碼的交流／複用更為便利。</p>
<h3 id="安裝-Node-js"><a href="#安裝-Node-js" class="headerlink" title="安裝 Node.js"></a>安裝 Node.js</h3><p>在 macOS 安裝 Node.js 非常簡單，在終端環境輸入指令來安裝最新版的 <a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># The latest version of Node.js</span></div><div class="line">brew install node</div><div class="line"></div><div class="line"><span class="comment"># 檢查是否安裝成功（成功則顯示最新版本版號）</span></div><div class="line">node -v</div><div class="line"><span class="comment">### v7.7.1</span></div></pre></td></tr></table></figure>
<p>同時 Node.js 也附帶如同 <strong>python</strong>、<strong>irb</strong> 的直譯式互動環境（<a href="https://en.wikipedia.org/wiki/Read–eval–print_loop" target="_blank" rel="external">REPL</a>）可快速測試／開發一些功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 進入 REPL 環境</span></div><div class="line">node</div><div class="line"></div><div class="line"><span class="comment"># -- REPL 環境 --</span></div><div class="line">&gt; 1 + 2</div><div class="line"><span class="comment">### 3</span></div><div class="line">&gt; <span class="string">'cat,mouse,dog'</span>.split(/,/)</div><div class="line"><span class="comment">### [ 'cat', 'mouse', 'dog' ]</span></div></pre></td></tr></table></figure>
<h3 id="Node-js-內建模組、變數"><a href="#Node-js-內建模組、變數" class="headerlink" title="Node.js 內建模組、變數"></a>Node.js 內建模組、變數</h3><p>Node.js 提供豐富的原生模組，可以操作 filesystem、socket、os 等系統層的 API，讓 Javascript 躋身至與 Python、Ruby 之流同樣地位，成為流行的腳本語言（<a href="https://en.wikipedia.org/wiki/Scripting_language" target="_blank" rel="external">scripting language</a>）。這裡列出前端開發者較常使用的幾個模組：</p>
<ul>
<li><code>os</code>：作業系統相關的操作與資訊</li>
<li><code>fs</code>：檔案系統的操作（移動／刪除／新增／檔案監控）</li>
<li><code>path</code>: 路徑相關工具模組（path resolve/join/pase/normalize）</li>
<li><code>assert</code>：斷言模組，通常與其他測試框架配合</li>
<li><code>child_process</code>：產生<a href="https://en.wikipedia.org/wiki/Child_process" target="_blank" rel="external">子行程（進程）</a>的模組，開發較複雜的自動化工具才會用到。</li>
</ul>
<p>另外，Node.js 同時提供許多重要的全域（Global）物件與函式，在全域下（Global Scope）皆可取得。</p>
<ul>
<li><code>global</code>：node 運行環境最上層的物件，類似瀏覽器端 <code>window</code> 的存在。</li>
<li><code>process</code>：記錄當前 node 運行環境的所有資訊。一般配合設置 <code>NODE_ENV</code> 環境變數來區別不同的開發階段。</li>
<li><code>__dirname</code>：模組所在目錄的名稱。實際上非全域物件，而是各模組皆有的變數。</li>
<li><code>__filename</code>：模組的檔案名，Node.js 世界，<strong>一個檔案為一個模組</strong>。實際上非全域物件，而是各模組皆有的變數。</li>
<li><code>require()</code>：用來引入（import）其他模組的函式。實際上非全域物件，而是各模組皆有的 method。</li>
<li><code>module</code>：Node.js 遵循 <a href="https://en.wikipedia.org/wiki/CommonJS" target="_blank" rel="external">CommonJS</a> 定義的「模組」模組，最常用到 <code>module.exports</code> 變數，這個變數會指向欲 export 的物件。</li>
</ul>
<blockquote>
<p>Node.js 模組 import／export 稍微複雜，可以參考<a href="https://www.sitepoint.com/understanding-module-exports-exports-node-js/" target="_blank" rel="external">用法教學</a>、<a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="external">深入講解 require</a>，或是直接閱讀<a href="https://nodejs.org/api/modules.html" target="_blank" rel="external">官方文件</a>。</p>
</blockquote>
<!-- -->
<blockquote>
<p>模組化的實作規範在 Javascript 界可謂群魔亂舞，所以 ECMA 2015 (ES6) 提出新的模組化 API（<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-imports" target="_blank" rel="external">imports</a>／<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-exports" target="_blank" rel="external">exports</a>），未來甚至可在瀏覽器端使用。目前可透過 Babel 轉譯器的<a href="https://www.npmjs.com/package/babel-plugin-transform-es2015-modules-commonjs" target="_blank" rel="external">外掛</a>搶先體驗。</p>
</blockquote>
<h3 id="Node-js-版本管理工具"><a href="#Node-js-版本管理工具" class="headerlink" title="Node.js 版本管理工具"></a>Node.js 版本管理工具</h3><p>蓬勃社群使得 Node.js 不斷精進，但也帶來軟體工程最痛苦的「版本相容」問題。許多時候，我們需要在最新的 Node 版本中測試新功能，但仍需要維護依賴舊版的專案。在不同 Node 版本環境間切換成本不低，幸虧有牛人寫了易用的版本管理工具 <a href="https://github.com/creationix/nvm" target="_blank" rel="external"><code>nvm</code></a> 與 <a href="https://github.com/tj/n" target="_blank" rel="external"><code>n</code></a>，讓版本切換變得輕鬆愉快。</p>
<p>以下主要介紹 <code>nvm</code> 的特色、安裝與簡易用法。<code>nvm</code> 的特色如下：</p>
<ul>
<li>使用 shell script 寫成，無其他相依模組／環境。</li>
<li>每個不同版本的 node 有自己的 global modules 環境，不互相影響。</li>
<li>更新至新版時，一行指令就可以重新安裝相同的 global packages。</li>
</ul>
<p><strong>總之，先開啟你的終端機吧！</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 透過 homebrew 安裝 nvm（macOS）</span></div><div class="line">brew install nvm</div><div class="line"></div><div class="line"><span class="comment"># 在使用者家目錄下，新增一個 .nvm 的工作目錄</span></div><div class="line">mkdir ~/.nvm</div><div class="line"></div><div class="line"><span class="comment"># 使用預設編輯器開啟 ~/.bash_profile</span></div><div class="line"><span class="variable">$EDITOR</span> ~/.bash_profile</div></pre></td></tr></table></figure>
<p>在你預設（或者你最喜愛）的編輯器裡，將下列兩行設定加入 .bash_profile 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 將下列設定加在 .bash_profile 中，讓 shell 讀取 nvm 設定</span></div><div class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></div><div class="line">. <span class="string">"/usr/local/opt/nvm/nvm.sh"</span></div></pre></td></tr></table></figure>
<p>離開編輯器，回到終端機畫面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 檢查設定是否正確</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$NVM_DIR</span></div><div class="line"><span class="comment">### /Users/weihanglo/.nvm</span></div><div class="line"></div><div class="line"><span class="comment"># 重新讀取 .bash_profile，讓剛剛的設定生效</span></div><div class="line"><span class="built_in">source</span> ~/.bash_profile</div></pre></td></tr></table></figure>
<p>現在可以開始安裝不同版本的 node 了！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 安裝最新版的 Node.js</span></div><div class="line">nvm install node</div><div class="line"></div><div class="line"><span class="comment"># 安裝／移除特定版本</span></div><div class="line">nvm install v6.9.0</div><div class="line">nvm install v7.6.0</div><div class="line">nvm uninstall node</div><div class="line"></div><div class="line"><span class="comment"># 設定預設使用的版本</span></div><div class="line">nvm <span class="built_in">alias</span> default v7.6.0</div><div class="line"></div><div class="line"><span class="comment"># 切換至其他版本</span></div><div class="line">nvm use v7.6.0</div><div class="line"><span class="comment"># or</span></div><div class="line">nvm use default</div><div class="line"></div><div class="line"><span class="comment"># 列出 local 已經安裝的版本</span></div><div class="line">nvm ls</div><div class="line"><span class="comment">###         v6.9.0</span></div><div class="line"><span class="comment">### -&gt;      v7.6.0</span></div><div class="line"><span class="comment">### default -&gt; v7.6.0</span></div><div class="line"></div><div class="line"><span class="comment"># 安裝新版 Node.js，並從其他版本安裝相同的 packages／modules</span></div><div class="line">nvm install v7.7.1 --reinstall-packages-from=v7.4.0</div></pre></td></tr></table></figure>
<blockquote>
<p>使用 <strong>nvm</strong> 至今，個人唯一詬病的是 script 體積較大，拖慢 shell startup time，社群有人發現此問題，並提出<a href="https://www.reddit.com/r/node/comments/4tg5jg/lazy_load_nvm_for_faster_shell_start/d5ib9fs/" target="_blank" rel="external">解法</a>。我稍作修改，去蕪存菁，只讀取 default version 的 binary，略提升 startup 時間（畢竟敝人的 <code>.bashrc</code> 已不瘦了），<a href="https://github.com/weihanglo/dotfiles/blob/master/.bashrc#L97-L122" target="_blank" rel="external">這段 script 提供大家參考</a>。</p>
</blockquote>
<h2 id="NPM-套件模組管理工具"><a href="#NPM-套件模組管理工具" class="headerlink" title="NPM 套件模組管理工具"></a>NPM 套件模組管理工具</h2><p>常言道，成功的程式語言背後，有個支持它的生態圈。Python／R 透過科學與統計的模組生態，在資料科學界中獨霸一方；Docker 把 Go 語言從鬼門關前救回，Go 因此成為 Container 界的王者；Node.js／Javascript 則是藉由方便易用的 <a href="https://www.npmjs.com/" target="_blank" rel="external"><code>npm</code></a>，讓才華洋溢的<del>宅男</del>工程師們盡情交流，創造出成千上萬個模組。</p>
<p>以下列出 npm 的特色：</p>
<ul>
<li>為 Node.js 預設的套件管理工具，安裝 Node.js 會一併安裝 npm。</li>
<li><strong>npm, Inc</strong> 提供套件伺服器 <a href="https://docs.npmjs.com/misc/registry" target="_blank" rel="external">npm Registry</a> 供開發者上傳／下載套件。（截止 2017.3.9 有 43 萬餘套件）。</li>
<li>提供 <code>package.json</code> 供使用者管理專案的相依模組／套件。</li>
<li>根據 <code>package.json</code> 的設定，進行更複雜的任務，如 test runner、build tool、watch file changes。</li>
</ul>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p><code>package.json</code> 是一個 Node.js 模組最重要的檔案，記錄與此模組相關的設定，部分第三方套件的配置文件也可以寫在 <code>package.json</code> 裡，減少 project 設定檔過多的問題（例如：babel、browserslist）。</p>
<p>合法的 <code>package.json</code> 除了要是一個 <a href="http://www.json.org/" target="_blank" rel="external">JSON</a> 格式檔案之外，還<strong>必須包含</strong>下列兩個重要的 fields：</p>
<ul>
<li><code>name</code>：模組名稱，也是import 模組時的名稱。在 npm Registry 通常是以相同或近似的名稱註冊，命名慣例以<code>-</code>（hyphen）取代 camelCase。</li>
<li><code>version</code>：模組目前的版號，npm 遵循<a href="http://semver.org/" target="_blank" rel="external">語意化版號</a>的標準，減少套件更新異動造成的問題。</li>
</ul>
<p>其他重要且建議填寫的 fields 有：</p>
<ul>
<li><code>main</code>：程式進入點，也是模組進入點（該檔案的 <code>module.exports</code>），慣例為 <code>index.js</code> 或 <code>main.js</code>。</li>
<li><code>devepdencies</code>：該模組直接相依的第三方模組。規範採用<a href="http://semver.org/" target="_blank" rel="external">語意化版號</a>標準。</li>
<li><code>devDependencies</code>： 該模組開發時會使用到相依模組，例如<strong>測試模組、打包模組</strong>。規範採<a href="http://semver.org/" target="_blank" rel="external">語意化版號</a>標準。</li>
<li><code>scripts</code>：自定義的 shell 腳本。可透過 <code>npm run &lt;command&gt;</code> 執行。</li>
<li><code>license</code>：模組的授權條款，建議填寫。</li>
<li><code>bin</code>：若模組有提供指令列程式，需在此配置指令名稱與對應檔案。</li>
</ul>
<p>在此概述常用的版號語法：</p>
<ul>
<li><code>1.2.3</code>：指定使用版號 1.2.3</li>
<li><code>&gt;1.2.3</code>：接受版號大於 1.2.3</li>
<li><code>&gt;=1.2.3</code>：接受版號大於等於 1.2.3</li>
<li><code>~1.2.3</code>：接受 patch version，同義於 <code>&gt;=1.2.3 &lt;1.3.0</code></li>
<li><code>^1.2.3</code>：只接受 minor version 或 non-breaking changes，同義於 <code>&gt;=1.2.0 &lt;2.0.0</code></li>
<li><code>*</code>：接受任何版號。</li>
</ul>
<blockquote>
<p><code>~</code>（tilde）與 <code>^</code>（caret）, 在版號寫法不同時，有不同結果，請參考 <a href="https://docs.npmjs.com/misc/semver#tilde-ranges-123-12-1" target="_blank" rel="external">node-semver 官方文件</a>。</p>
</blockquote>
<p>一個合法的 <code>package.json</code> 範例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"electron-react-demo"</span>, <span class="comment">// 模組名稱，以 hyphen 取代 camelCase</span></div><div class="line">  <span class="string">"version"</span>: <span class="string">"0.0.1"</span>, <span class="comment">// 當前版號</span></div><div class="line">  <span class="string">"description"</span>: <span class="string">"A Electron Demo with React"</span>, <span class="comment">// 模組簡介</span></div><div class="line">  <span class="string">"main"</span>: <span class="string">"main.js"</span>, <span class="comment">// 程式進入點／模組進入點</span></div><div class="line">  <span class="string">"scripts"</span>: &#123; <span class="comment">// 自定義腳本</span></div><div class="line">    <span class="string">"start"</span>: <span class="string">"electron ."</span> <span class="comment">// 輸入 `npm run start` 或 `npm start` 時會執行的腳本</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"Weihang Lo"</span>, <span class="comment">// 作者欄位</span></div><div class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span>, <span class="comment">// 授權／版權條款</span></div><div class="line">  <span class="string">"dependencies"</span>: &#123; <span class="comment">// 直接相依的模組</span></div><div class="line">    <span class="string">"react"</span>: <span class="string">"~15.4.1"</span>, <span class="comment">// 使用 patch version 的 react</span></div><div class="line">    <span class="string">"react-dom"</span>: <span class="string">"~15.4.1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123; <span class="comment">// 開發用的模組</span></div><div class="line">    <span class="string">"babel-preset-es2015"</span>: <span class="string">"^6.18.0"</span>, <span class="comment">// 版號 &gt;= 6.18.0 但小於 &lt; 7.0.0</span></div><div class="line">    <span class="string">"babel-preset-react"</span>: <span class="string">"^6.16.0"</span>,</div><div class="line">    <span class="string">"electron"</span>: <span class="string">"1.4.12"</span>, <span class="comment">// 使用指定版號的 electron</span></div><div class="line">    <span class="string">"mocha"</span>: <span class="string">"*"</span>, <span class="comment">// 使用最新／任意版本。</span></div><div class="line">    <span class="string">"chai"</span>: <span class="string">"*"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>還有許多沒介紹到的 <code>package.json</code> 設定，在 <a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">npm 官方文件</a> 裡應有盡有！</p>
<h3 id="NPM-常用指令"><a href="#NPM-常用指令" class="headerlink" title="NPM 常用指令"></a>NPM 常用指令</h3><p>npm 的指令列程式提供許多功能，其中最重要的兩類即是<strong>模組</strong>和<strong>執行腳本</strong>相關的指令。</p>
<p><strong>安裝／移除／更新／列出 相依模組</strong></p>
<ul>
<li><code>npm install [--global] [--save] [--save-dev]</code></li>
<li><code>npm uninstall [--global] [--save] [--save-dev]</code></li>
<li><code>npm ls [--global] [--depth=&lt;number&gt;]</code></li>
<li><code>npm update [--global]</code></li>
</ul>
<p>開始介紹前，先了解 npm 安裝模組的模式，分為 <strong>全域模式（globally）</strong> 與 <strong>本地模式（locally）</strong></p>
<ul>
<li>全域模式 <code>--global</code>：安裝的模組通常是常用的指令列程式，例如 npm 本身。</li>
<li>本地模式：用來安裝與 project 相依的模組，會在 project 根目錄產生一個 <code>node_modules</code> 存放相依模組。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 創建一個 npm 模組環境（互動式產生 package.json）</span></div><div class="line">npm init</div><div class="line"></div><div class="line"><span class="comment"># 尋找同目錄下的 `package.json`，安裝該檔案內記錄的相依套件</span></div><div class="line">npm install</div><div class="line"></div><div class="line"><span class="comment"># 安裝 axios 套件，不儲存相依關係。</span></div><div class="line">npm install axios</div><div class="line"></div><div class="line"><span class="comment"># 安裝 bluebird 套件，並將相依版號寫入 `package.json` 的 `dependencies` field 中</span></div><div class="line">npm install bluebird --save</div><div class="line"></div><div class="line"><span class="comment"># 安裝 mocha、chai 套件，並將相依版號寫入 `package.json` 的 `devDependencies` field 中（開發用套件）</span></div><div class="line">npm install mocha chai --save-dev</div><div class="line"></div><div class="line"><span class="comment"># 安裝 Globally 的套件，在任何目錄都可直接使用該模組的指令列程式</span></div><div class="line">npm install --global yarn</div><div class="line"></div><div class="line"><span class="comment"># 移除 bluebird 套件，並從 `package.json` 中移除相依關係</span></div><div class="line">npm uninstall bluebird --save</div><div class="line"></div><div class="line"><span class="comment"># 列出 locally（project-wide） 的套件到第一階層（專案的相依套件的相依套件）</span></div><div class="line">npm ls --depth=2</div><div class="line"></div><div class="line"><span class="comment"># 列出全域安裝的套件（只列出 user 直接安裝的套件）</span></div><div class="line">npm ls --global --depth=0</div><div class="line"></div><div class="line"><span class="comment"># 更新 bluebird 套件至 package.json 內的指定版號</span></div><div class="line">npm update bluebird</div><div class="line"></div><div class="line"><span class="comment"># 更新 package.json 記錄的套件至指定版號</span></div><div class="line">npm update</div><div class="line"></div><div class="line"><span class="comment"># 更新所有全員安裝的套件</span></div><div class="line">npm update --global</div></pre></td></tr></table></figure>
<blockquote>
<p>Facebook、Google 幾個大頭在 2016 年 10 月 開源了新一代的 Node.js 套件管理工具 <a href="https://yarnpkg.com/" target="_blank" rel="external">Yarn</a>，在速度、體驗、介面上皆略勝 npm 一籌。Yarn 也會自動產生 <code>yarn.lock</code> 檔案，精確記錄相依模組的版號，在套件管理上更安全安心，有興趣的童鞋可嘗試看看。</p>
</blockquote>
<p><strong>執行自定義腳本</strong></p>
<ul>
<li><code>npm run &lt;command&gt; [-- &lt;args&gt;...]</code></li>
</ul>
<p>用來執行 <code>package.json</code> 的 <code>scripts</code> field 中的自定義腳本。在執行開始前，<code>npm run</code> 會在既有的 <a href="https://en.wikipedia.org/wiki/PATH_(variable)" target="_blank" rel="external">PATH</a> 環境變數加上 <code>node_modules/.bin</code>，許多套件提供的 binary 執行檔可以直接執行，不需要再加上 <code>./node_modules/.bin/a-command</code> 等冗長的相對路徑。因此，<code>npm run</code> 常作為 task/test runner、build tools 的入口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 在 `package.json` 裡</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"start"</span>: <span class="string">"echo 'Start my node.js app'"</span>,</div><div class="line">    <span class="string">"fail"</span>: <span class="string">"echo \"Oops! Failed on <span class="variable">$1</span>\""</span>,</div><div class="line">    <span class="string">"serve"</span>: <span class="string">"serve"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 回到終端環境，先安裝相依套件</span></div><div class="line">npm install serve</div><div class="line"></div><div class="line"><span class="comment"># 等同於執行 `./node_modules/.bin/serve`，開啟一個 local http server</span></div><div class="line">npm run serve</div><div class="line"><span class="comment">### Serving!</span></div><div class="line"></div><div class="line"><span class="comment"># `--` 可傳入參數等，同執行 `echo 'Oops! Failed $1`</span></div><div class="line">npm run fail -- Example</div><div class="line"><span class="comment">### Oops! Failed on Example</span></div><div class="line"></div><div class="line"><span class="comment"># `start`、`test`、`restart` 等 script 可不透過 `run`，直接使用簡寫執行</span></div><div class="line">npm run start</div><div class="line"><span class="comment">### Start my node.js app</span></div><div class="line"></div><div class="line">npm start</div><div class="line"><span class="comment">### Start my node.js app</span></div></pre></td></tr></table></figure>
<p>除了上述 npm 還有許多功能，族繁不及備載，詳情請參考 <a href="https://docs.npmjs.com/getting-started#cli" target="_blank" rel="external">npm - Cli Commands</a>。有關 <code>npm run-script</code>，也可以瞧瞧<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="external">這篇教學</a>。</p>
<h2 id="預處理器／轉譯器"><a href="#預處理器／轉譯器" class="headerlink" title="預處理器／轉譯器"></a>預處理器／轉譯器</h2><p>雖然 Node.js／npm 為 Javascript 生態圈帶來前所未有的繁榮盛況，但前端的世界還是處處充滿危機，不同瀏覽器廠商的實作參差不齊，開發者常搞不清楚<a href="http://caniuse.com/" target="_blank" rel="external">可以用哪些 CSS 與 Javascript 的 features</a>，開源社群為了消弭這些惱人的問題，開發出許多協助開發者的<a href="https://github.com/showcases/css-preprocessors" target="_blank" rel="external">預處理器</a>／<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler" target="_blank" rel="external">轉譯器（transpiler）</a>。</p>
<blockquote>
<p>預處理器／轉譯器屬於 <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler" target="_blank" rel="external">source-to-source compiler</a>，雖然可以加速開發，但也需要引入 build tools 協助轉換語法，有關 build tools／task runner，會在<a href="#自動化工具打包工具">自動化工具／打包工具</a>與各位分享。</p>
</blockquote>
<h3 id="CSS-預處理器"><a href="#CSS-預處理器" class="headerlink" title="CSS 預處理器"></a>CSS 預處理器</h3><p>CSS 對程序猿來說，沒有繼承，沒有函式，沒有變數，全部的設定都在 global scope，完全符合設計不良的語言特性。有志青年打造了許多<a href="https://github.com/showcases/css-preprocessors" target="_blank" rel="external">類似 CSS 的語言</a>，提供變數、函式、<a href="https://en.wikipedia.org/wiki/Mixin" target="_blank" rel="external">mixin</a>，再 compile 成 vanilla CSS，讓寫 CSS 能夠更輕鬆，更能專注商業邏輯。這些方便的工具我們通稱 <strong>CSS Preprocessor</strong>。</p>
<p>目前主流的 <strong>CSS Preprocessor</strong> 有 <a href="http://lesscss.org/" target="_blank" rel="external">Less</a>、<a href="http://sass-lang.com/" target="_blank" rel="external">Sass</a>，以及 <a href="http://stylus-lang.com/" target="_blank" rel="external">Stylus</a> 等，每一套都有各自的擁護者，在此簡單比較 <strong>Sass</strong> 與 vanilla CSS，給客倌看看。</p>
<p><strong>Vanilla CSS（同一個 nav 下的元素要分為三個 block 撰寫，且相同的 padding 要寫兩次）</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span> <span class="selector-tag">li</span> &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span></div><div class="line">  display: inline-block;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</div><div class="line">  <span class="attribute">text-decoration</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Sass（SCSS syntax）支援 <a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#variables_" target="_blank" rel="external">variable</a> 與 <a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#nested_rules" target="_blank" rel="external">nested element selector</a></strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><div class="line"><span class="variable">$my-vertical-padding</span>: <span class="number">6px</span>;</div><div class="line"><span class="variable">$my-horizontal-padding</span>: <span class="number">12px</span>;</div><div class="line"></div><div class="line"><span class="selector-tag">nav</span> &#123;</div><div class="line">  <span class="selector-tag">ul</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">padding</span>: <span class="variable">$my-vertical-padding</span> <span class="variable">$my-horizontal-padding</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="selector-tag">a</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">padding</span>: <span class="variable">$my-vertical-padding</span> <span class="variable">$my-horizontal-padding</span>;</div><div class="line">    <span class="attribute">text-decoration</span>: none;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Sass 是 Ruby 社群發展出來的 CSS 預處理器，在 Javascript 界通常使用 <a href="https://github.com/sass/node-sass" target="_blank" rel="external">node-sass</a> 做 CSS transform。Sass 是個人非常喜愛的 CSS 預處理器。</p>
</blockquote>
<h3 id="CSS-後處理器"><a href="#CSS-後處理器" class="headerlink" title="CSS 後處理器"></a>CSS 後處理器</h3><p>對前端開發者來說，最痛苦的莫過於在 Chrome 切好 layout，卻在 Safari 跑版。在 Firefox 做 css animation，卻在 Safari 動彈不得。這些問題來自於各瀏覽器實作不同，添加的 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix" target="_blank" rel="external">vendor prefix</a> 也不一樣，我們可以透過 <a href="https://www.sitepoint.com/sass-mixins-kickstart-project/" target="_blank" rel="external">Sass 的 mixin 來解決 prefix 問題</a>，但這不夠 fancy，CSS 後處理器概念營運而生，最有名的莫過於 <a href="http://postcss.org/" target="_blank" rel="external">postcss</a> 的 Plugin <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="external">autoprefixer</a>，在 CSS 預處理器 compile 完成之後，需要的 property 加上 vendor prefix，完全不需要再寫一丁點 mixin。</p>
<blockquote>
<p>順水推舟，<a href="http://postcss.org/" target="_blank" rel="external">postcss</a> 是個生態豐富的 css transforming plugin system，許多瀏覽器未實作的 feature，透過 plugin 轉換，就可以使用各種 feature了。</p>
</blockquote>
<h3 id="ES6-／Babel"><a href="#ES6-／Babel" class="headerlink" title="ES6+／Babel"></a>ES6+／Babel</h3><p>Javascript 從出生到現在，一直是個被人嫌棄的語言，弱型別，隱式轉換，缺乏真正物件導向概念（只有 prototype oriented），變數可重複宣告，<a href="http://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work" target="_blank" rel="external"><code>this</code> 的語意</a>更讓人摸不著頭緒。近年來，ECMAScript 的標準不斷往前走，加入了 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="external">作用域變數 scope variable（<code>let</code>）</a>、<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="external">常數宣告 constant declaration（<code>const</code>）</a>，自動綁定 <code>this</code> 的 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">arrow function</a>，甚至原生的 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">class</a> 等語言新特性。徹底改造整個 Javascript 的生態圈。</p>
<p>可惜又面臨同個問題，目前的瀏覽器／Node.js 環境不一定支援。社群又跳出來，寫了名為 <a href="http://babeljs.io/" target="_blank" rel="external"><code>Babel</code></a>（借用巴別塔的典故）的 transpiler，將最新的 Javascript 語法，轉換成當前瀏覽器相容的語法。透過 <a href="http://babeljs.io/" target="_blank" rel="external">Babel</a>，我們可歡樂地使用 ES6 的 class，不必擔心 IE 會 crash 了！</p>
<p>以下介紹 Babel 的簡易設定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 在你的專案目錄底下安裝 babel 套件</span></div><div class="line">npm install --save-dev babel-cli babel-preset-env</div><div class="line"></div><div class="line"><span class="comment"># 使用預設編輯器開啟 .babelrc（Babel 設定檔）</span></div><div class="line"><span class="variable">$EDITOR</span> ~/.bash_profile</div></pre></td></tr></table></figure>
<p>在你預設（或者你最喜愛）的編輯器裡，將下列設定加入 <code>.babelrc</code>（Babel 設定檔） 中：<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 在 .babelrc 中加入下列設定</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下來利用你喜愛的 task runner，把你的 code compile 成瀏覽器相容的 javascript 吧！</p>
<blockquote>
<p>Babel 提供許多不同的預處理器（presets），例如 es2015、es2017，<code>env</code> 是目前 Babel 官方推薦的 presets，可以透過設定 <a href="https://github.com/ai/browserslist" target="_blank" rel="external"><code>browserslist</code></a>，依據不同生產環境決定哪些語法需要轉換，<strong>autoprefixer</strong> 與 <strong>eslint</strong> 同樣也支援 <code>browserslist</code>。</p>
</blockquote>
<!-- -->
<blockquote>
<p>另一個有名且有前景的轉譯器是微軟出品的 <a href="https://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a>，支援繼承、抽象介面、裝飾器、型別檢查等 features，現代語言該有的應有盡有。由於是 Javascript 的 superset，在 TypeScript 裡寫 Javascript 完全合法，且 Google 的 <a href="https://angular.io/" target="_blank" rel="external">Angular</a> Framework，以及有名的 Reactive Programing Libary <a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="external">RxJS</a> 也都採用 TypeScript。值得一試！</p>
</blockquote>
<h2 id="自動化工具／打包工具"><a href="#自動化工具／打包工具" class="headerlink" title="自動化工具／打包工具"></a>自動化工具／打包工具</h2><p>使用這麼多預處理器／轉譯器／自定義腳本，如果每次都需要自己 <code>npm run compile</code>、<code>babel script.js</code> 豈不麻煩？為了減少重複性的任務（task），Javascript 生態圈發展出數套實用的 build tool／system，老牌的 <a href="https://gruntjs.com/" target="_blank" rel="external">Grunt</a> 與較年輕的 <a href="http://gulpjs.com/" target="_blank" rel="external">Gulp</a>，這裡選擇使用 <a href="http://gulpjs.com/" target="_blank" rel="external">Gulp</a>。</p>
<p>另外，當我們想使用 npm 上的各種模組，卻很難直接在瀏覽器端引入這些 dependencies。打包工具如 <a href="http://browserify.org/" target="_blank" rel="external"><code>Browserify</code></a> 與 <a href="https://webpack.js.org/" target="_blank" rel="external">Webpack</a> 提供我們將這些散落各處的 .js、.css、.html 打包起來的方法，便於 import 到瀏覽器客戶端。這裡主要介紹 <a href="https://webpack.js.org/" target="_blank" rel="external">Webpack</a>。</p>
<h3 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h3><p><a href="http://gulpjs.com/" target="_blank" rel="external">Gulp</a> 是一個直觀易懂的 build system，其概念是利用 Node.js 的 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">stream</a> API，有如 <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)" target="_blank" rel="external">pipeline</a> 般將檔案傳遞到每個 plugin／transformer 中做對應的任務。而 Gulp 也有豐富的 plugin 生態系，提供許多主流預處理器的 plugin，讓結果如同 stream 一樣容易產出。</p>
<p>以下簡單示範 gulp 安裝與用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 1. 首先先安裝 Global gulp command-line tool</span></div><div class="line">npm install --global gulp-cli</div><div class="line"></div><div class="line"><span class="comment"># 2. 接著在 project 將 gulp 安裝為 devDependencies</span></div><div class="line">npm install --save-dev gulp</div></pre></td></tr></table></figure>
<p>在 project root 新增 gulpfile.js，並寫入這些設定：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 3. gulpfile.js at project root</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 你的預設 task</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>回到終端環境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 4. 輸入 `gulp`，執行預設的 task：</span></div><div class="line">gulp</div><div class="line"><span class="comment">### [14:20:30] Using gulpfile ~/Documents/gulp-demo/gulpfile.js</span></div><div class="line"><span class="comment">### [14:20:30] Starting 'default'...</span></div><div class="line"><span class="comment">### [14:20:30] Finished 'default' after 361 μs</span></div></pre></td></tr></table></figure>
<p>Gulp 本身的 <a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="external">API 不多</a>，語法也很簡單，這邊舉例並說明 <code>gulpfile.js</code> 實例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 確認有先安裝相依的 babel 套件 與 del 套件</span></div><div class="line"><span class="comment">// `npm install --save-dev gulp-babel babel-preset-env del`</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);             <span class="comment">// import gulp 套件（必須）</span></div><div class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);      <span class="comment">// import gulp-babel 插件</span></div><div class="line"><span class="keyword">var</span> del = <span class="built_in">require</span>(<span class="string">'del'</span>);               <span class="comment">// import del 套件（用來 cleanup output）</span></div><div class="line"></div><div class="line">gulp.task(<span class="string">'babel'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;        <span class="comment">// 建立一個叫做 babel 的任務</span></div><div class="line">  gulp.src(<span class="string">'src/**/*.js'</span>)               <span class="comment">// `gulp.src` 會讀取給定路徑（src 下所有 js 檔）的檔案</span></div><div class="line">    .pipe(babel(&#123; <span class="attr">presets</span>: [<span class="string">'env'</span>] &#125;))  <span class="comment">// 將上一步的檔案 pipe 給 babel plugin 處理</span></div><div class="line">    .pipe(gulp.dest(<span class="string">'dist'</span>));           <span class="comment">// 將上一步的檔案透過 `gulp.dest` 輸出到給定路徑（dist）</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;        <span class="comment">// 建立一個叫做 clean 的任務</span></div><div class="line">    del([<span class="string">'dist'</span>]);                      <span class="comment">// 使用 `del` 套件，刪除輸出的目錄 (dist)</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'clean'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 建立預設任務，並設 clean 為相依任務（在該任務執行前執行）</span></div><div class="line">  gulp.watch(<span class="string">'src/**/*.js'</span>, [<span class="string">'babel'</span>]); <span class="comment">// 使用 `gulp.watch` 監視檔案異動，有異動就執行 babel 任務</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在終端環境下，我們這樣做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 先寫一個假的 ES6 js file</span></div><div class="line">mkdir src</div><div class="line"><span class="built_in">echo</span> <span class="string">" (() =&gt; console.log('Hello, world!'))() "</span> &gt; src/demo.js</div><div class="line"></div><div class="line"><span class="comment"># 執行 babel 任務</span></div><div class="line">gulp babel</div><div class="line"><span class="comment">### [14:42:23] Using gulpfile ~/Documents/gulp-babel-demo/gulpfile.js</span></div><div class="line"><span class="comment">### [14:42:23] Starting 'babel'...</span></div><div class="line"><span class="comment">### [14:42:23] Finished 'babel' after 9.31 ms</span></div><div class="line"></div><div class="line"><span class="comment"># 測試是否正確 compile 成功</span></div><div class="line">node src/demo.js</div><div class="line"><span class="comment">### Hello, world!</span></div><div class="line"></div><div class="line"><span class="comment"># 清除輸出檔案</span></div><div class="line">gulp clean</div><div class="line"><span class="comment">### [14:56:18] Using gulpfile ~/Documents/gulp-babel-demo/gulpfile.js</span></div><div class="line"><span class="comment">### [14:56:18] Starting 'clean'...</span></div><div class="line"><span class="comment">### [14:56:18] Finished 'clean' after 4.34 ms</span></div><div class="line"></div><div class="line"><span class="comment"># 測試是否正確清除 `dist` 目錄</span></div><div class="line">ls</div><div class="line"><span class="comment">### gulpfile.js  node_modules package.json src</span></div><div class="line"></div><div class="line"><span class="comment"># 執行 `gulp`，會先執行 clean（相依任務），再執行 default（預設任務）</span></div><div class="line">gulp</div><div class="line"><span class="comment">### [14:48:30] Using gulpfile ~/Documents/gulp-babel-demo/gulpfile.js</span></div><div class="line"><span class="comment">### [14:48:30] Starting 'clean'...</span></div><div class="line"><span class="comment">### [14:48:30] Finished 'clean' after 12 ms</span></div><div class="line"><span class="comment">### [14:48:30] Starting 'default'...</span></div><div class="line"><span class="comment">### [14:48:30] Finished 'default' after 9.36 ms</span></div></pre></td></tr></table></figure>
<p>欲了解其他 Plugin／用法，可直接 <a href="http://gulpjs.com/" target="_blank" rel="external">Gulp 官網</a>，或直接搜尋 <code>gulp + &lt;something&gt;</code>，神人都幫你做好了。</p>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p><a href="https://webpack.js.org/" target="_blank" rel="external">Webpack</a> 是近幾年來最熱門的打包工具，透過解析模組之間的相依關係，可以</p>
<ul>
<li>把專案中 js、css、和其他靜態 assets 打包到同一個檔案中</li>
<li>將不同頁面／模組的<a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="external">程式碼分離（code splitting）</a></li>
<li>透過 <a href="https://webpack.js.org/concepts/loaders/" target="_blank" rel="external">loader system</a>，轉換／編譯 Sass、Babel、TypeScript 甚至圖片等不同檔案 （多數情況下能取代 Gulp、Grunt 等工具）</li>
<li>運用不同的 Plugins，組合出適合自己的 Webpack 流程與設定。</li>
</ul>
<p>Webpack 最簡單的設定，就是在 project root 新增一個 <code>webpack.config.js</code> 檔案，以下範例取自 <a href="https://webpack.js.org/concepts/" target="_blank" rel="external">Webpack 的核心觀念</a>（使用 Webpack 2）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// in `webpack.config.js`</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">//to access built-in plugins</span></div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./path/to/my/entry/file.js'</span>,      <span class="comment">// 1. 程式進入點設定</span></div><div class="line">  output: &#123;                                 <span class="comment">// 2. 打包輸出設定</span></div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;                                 <span class="comment">// 3. loaders（轉換檔案 -&gt; Javascript）</span></div><div class="line">    rules: [</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [                                <span class="comment">// 4. 其他有用的 plugins</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Webpack 的簡易運作流程如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">找到 entry file</div><div class="line">-&gt; 解析相依模組</div><div class="line">-&gt; 符合 test rules 的模組由 loaders 轉換處理</div><div class="line">-&gt; 將所有處理完成的檔案打包成 output 的 js 檔</div></pre></td></tr></table></figure></p>
<p>其中，在 <code>webpack.config.js</code> 設定檔中，最核心四個概念如下：</p>
<p><strong><code>entry</code></strong></p>
<p>程式進入點，webpack 會從這個（些）檔案開始解析所有相依（require／import）的模組、CSS、圖片（沒錯，Webpack 可以 import 圖片，將圖片視為模組）。一個可以有多個 entries。</p>
<p><strong><code>output</code></strong></p>
<p>打包完成的 <code>.js</code> 輸出的路徑設定，可根據多個 entries 輸出對應的 output。也可以利用內建的 <code>CommonsChunkPlugin</code> 來分離不同區塊／模組／套件的 output js 檔案。</p>
<p><strong><code>loaders</code></strong></p>
<p>任何使用 import／require 等關鍵字的 dependencies 都會被 webpack 解析，但 webpack 只認得 Javascript，所以需要許多 loaders 協助轉換，例如 <code>sass-loader</code>、<code>css-loader</code>、<code>babel-loader</code> 等。 每條 <code>rules</code> 利用 Regex 的 <code>test</code> 來區分哪些檔案使用哪些 loaders 處理，<code>use</code> field 則是指定對應的 loader，可以串連多個 loaders。</p>
<p><strong><code>plugins</code></strong></p>
<p>使用其他 plugins 來客製化 webpack 的打包結果，例如範例中內建的 <code>UglifyJsPlugin</code> 則是壓縮混淆最終輸出的 bundle.js，也有類似 <a href="https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/master/README.md" target="_blank" rel="external"><code>extract-text-webpack-plugin</code></a> ，將 CSS 檔從 bundle.js 中分離等實用的 plugins。</p>
<!--  -->
<p>Webpack 近幾年風生水起，生態系也應運而生。礙於篇幅，不少非常實用設定，以及 loaders 與 plugins 例如 <code>style-loader</code>、<code>url-loader</code>、<code>HtmlWebpackPlugin</code> 等，在此無法一一贅述，有興趣可以參考<a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="external">這個教學</a>，也別忘了 <a href="https://webpack.js.org/" target="_blank" rel="external">Webpack 2 最新的官網</a>。</p>
<h2 id="程式碼品質"><a href="#程式碼品質" class="headerlink" title="程式碼品質"></a>程式碼品質</h2><p>一份好的程式碼，除了可以正確無誤的執行，更要讓人易讀易維護，本節將介紹</p>
<ul>
<li>如何使用現代化的 JS 測試框架，讓你不再害怕自己寫的程式碼。</li>
<li>選擇一個好用的靜態語法檢查器，提高可讀性，減少人為失誤。</li>
</ul>
<h3 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h3><p>所有工程師都知道測試的好處，也了解測試的必要性，但卻很少人主動寫測試。傳統 <a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="external">TDD（<del>Trump-driven</del> Test-driven development）</a>的先寫測試，再寫程式的流程較不直觀，且易淪為為測試而測試，脫離現實。隨後崛起的 <a href="https://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank" rel="external">BDD（Behavior-driven development）</a>則漸趨主流，強調測試只應在「程式行為不符預期時失敗」，是測「程式做了什麼」，而不是「程式如何做這些事」。</p>
<p>一些 BDD 的測試框架與 BDD 斷言庫也順勢產生，透過語意化的 API，讓測試員更能了解程式到底「幹了啥事」，增添寫測試的樂趣。這裡主要介紹 <a href="https://mochajs.org/" target="_blank" rel="external">Mocha</a> 測試框架，配合 <a href="http://chaijs.com/" target="_blank" rel="external">Chai</a> 斷言庫，達成「快樂寫測試，寫測試快樂」的最高境界。</p>
<p><a href="https://mochajs.org/" target="_blank" rel="external"><code>mocha</code></a> 與 <a href="http://chaijs.com/" target="_blank" rel="external"><code>chai</code></a> 安裝與使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 安裝 mocha、chai 兩個套件</span></div><div class="line">npm install --save-dev mocha chai</div><div class="line"></div><div class="line"><span class="comment"># 建立一個 test 目錄</span></div><div class="line">mkdir <span class="built_in">test</span></div><div class="line"></div><div class="line"><span class="comment"># 使用預設編輯器開啟 test/test.js（第一個測試檔案）</span></div><div class="line"><span class="variable">$EDITOR</span> <span class="built_in">test</span>/test.js</div></pre></td></tr></table></figure>
<p>在你預設（或者你最喜愛）的編輯器裡，將下列測試加入 test/test.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> chai = <span class="built_in">require</span>(<span class="string">'chai'</span>); <span class="comment">// 引入 `chai`（提供 asset／expect／should 風格斷言）</span></div><div class="line"></div><div class="line">chai.should(); <span class="comment">// 使用 should 前，需先執行 `chai.should()`，將 should 加到每個 Object</span></div><div class="line"></div><div class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;          <span class="comment">// Test Suite</span></div><div class="line">  describe(<span class="string">'#indexOf()'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">// mocha 可嵌套 Test Suite，讓意圖更清晰</span></div><div class="line">    it(<span class="string">'should include 2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 實際的 Test Case</span></div><div class="line">      <span class="keyword">const</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>];</div><div class="line">      array.should.include(<span class="number">2</span>);          <span class="comment">// 使用 should 風格進行斷言</span></div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>回到終端環境，執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 使用 mocha 模組的 command-line tool，進行測試</span></div><div class="line">./node_modules/.bin/mocha <span class="built_in">test</span>/test.js</div><div class="line"><span class="comment">###  Array</span></div><div class="line"><span class="comment">###    #indexOf()</span></div><div class="line"><span class="comment">###      ✓ should include 2</span></div><div class="line"><span class="comment">###</span></div><div class="line"><span class="comment">###  1 passing (10ms)</span></div></pre></td></tr></table></figure>
<blockquote>
<p>若希望直接執行 <code>mocha</code> 來測試，不想每次都加上模組路徑，可以</p>
<ol>
<li>在全域安裝 <code>mocha</code> 套件 <code>npm install --global mocha</code></li>
<li>在 <code>package.json</code> 加入一個 run-script<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="string">"test"</span>: <span class="string">"mocha path/to/your/test/dir/"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>如果想建立 TDD 式的 <code>setUp</code>、<code>tearDown</code> hooks，可以如下設計：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">describe(<span class="string">'hooks'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 在這個 block 內所有 test case 之前執行</span></div><div class="line">  &#125;);</div><div class="line">  after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 在這個 block 內所有 test case 之後執行</span></div><div class="line">  &#125;);</div><div class="line">  beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 在這個 block 內每個 test case 之前執行</span></div><div class="line">  &#125;);</div><div class="line">  afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 在這個 block 內每個 test case 之後執行</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>有需要非同步（異步）的測試，請</p>
<ol>
<li>在 test case 的 function params 加入 <code>done</code> 參數。</li>
<li>成功則調用 <code>done()</code>。</li>
<li>失敗則調用 <code>done(err)</code>，並加入 error 作為引數（argument）。</li>
</ol>
<p>這裡以 <code>Promise</code> 為例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">describe(<span class="string">'Async Tests'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  it(<span class="string">'should complete in the furture'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123; <span class="comment">// 加入 done 參數</span></div><div class="line">    someAsyncPromiseTest()  <span class="comment">// 一個異步的 Promise</span></div><div class="line">    .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</div><div class="line">      assert.ok(result);    <span class="comment">// 測試斷言</span></div><div class="line">      done();               <span class="comment">// 調用 done，通知 test runner 成功執行 async task</span></div><div class="line">    &#125;)</div><div class="line">    .catch(err, (err) =&gt; &#123;</div><div class="line">      done(err);            <span class="comment">// 調用 done 並傳入 error，通知 test runner 執行異常</span></div><div class="line">    &#125;)</div><div class="line">  &#125;);  </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 由於 `done` 是一個函式，上式也可簡寫成</span></div><div class="line">describe(<span class="string">'Async Tests'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  it(<span class="string">'should complete in the furture'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">    someAsyncPromiseTest()</div><div class="line">    .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</div><div class="line">      result.should.equal(<span class="string">'well done'</span>);</div><div class="line">      done();          </div><div class="line">    &#125;)</div><div class="line">    .catch(done); <span class="comment">// 直接傳入 done！</span></div><div class="line">  &#125;);  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>如果需要非同步的 hooks，同樣加入 <code>done</code> 參數，並調用 done。</p>
</blockquote>
<p>其他相關 mocha 語法 API，<a href="https://mochajs.org/" target="_blank" rel="external">mocha 網站</a>寫得非常清楚。有關斷言的寫法，也可直接參考 <a href="http://chaijs.com/" target="_blank" rel="external">chai 官網</a>。</p>
<h3 id="靜態程式語法檢查"><a href="#靜態程式語法檢查" class="headerlink" title="靜態程式語法檢查"></a>靜態程式語法檢查</h3><p>使用<a href="https://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank" rel="external">整合開發環境（IDE）</a>的童鞋，想必對<a href="https://en.wikipedia.org/wiki/Lint_(software)" target="_blank" rel="external">靜態語法檢查</a>有深刻體會。使用靜態語法檢查，會對程式碼撰寫的風格有所限制，但同時可以可防止許多 <a href="https://en.wikipedia.org/wiki/Code_smell" target="_blank" rel="external">bad code smell</a>，例如：</p>
<ul>
<li><a href="http://eslint.org/docs/rules/handle-callback-err" target="_blank" rel="external">一定要處理 error</a></li>
<li><a href="http://eslint.org/docs/rules/no-const-assign" target="_blank" rel="external">避免修改以 const 宣告的變數</a></li>
<li><a href="http://eslint.org/docs/rules/no-unexpected-multiline" target="_blank" rel="external">不要用 <code>(</code> <code>/</code> <code>.</code> <code>,</code> 等符號當開頭</a>（不寫分號唯一會遇到的問題！）</li>
</ul>
<p>Javascript 的 linter 有非常多套，這裡選用目前最流行、客製化程度最高的 <a href="http://eslint.org/" target="_blank" rel="external">ESLint</a> 作範例。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 安裝 eslint</span></div><div class="line">npm install --save-dev eslint</div><div class="line"></div><div class="line"><span class="comment"># 互動式建置 `.eslint.js` 配置文件</span></div><div class="line">./node_modules/.bin/eslint --init</div><div class="line"></div><div class="line"><span class="comment"># 之後就可以直接用 eslint 來檢查你的程式碼了</span></div><div class="line">./node_modules/.bin/eslint path/to/your/file.js</div></pre></td></tr></table></figure>
<blockquote>
<p>同樣地，可以在 <code>package.json</code> 加入一個 run-script，方便隨時 lint<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="string">"lint"</span>: <span class="string">"eslint .; exit 0;"</span> <span class="comment">// 有錯誤的話 eslint exit code 是 1， 我們手動 exit 0 以避免 npm 報錯。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<!--  -->
<blockquote>
<p>有些檔案不需要 linter 檢查（例如 test spec、其他套件的 config），可在 project root 加入 <code>.eslintignore</code> 忽略這些檔案（<a href="https://git-scm.com/docs/gitignore#_examples" target="_blank" rel="external">寫法同 <code>.gitignore</code></a>）。</p>
</blockquote>
<p>通常我們會用一些大廠的設定，簡化我們的 Linter config，例如使用 <a href="https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb" target="_blank" rel="external">Airbnb Javascript style</a>，如果需要客製化 linter 可以參考 <a href="http://eslint.org/docs/user-guide/configuring" target="_blank" rel="external">ESLint 如何配置</a>。</p>
<p>許多文字編輯器有整合的 eslint 的 plugin（如 <a href="https://atom.io/packages/linter-eslint" target="_blank" rel="external">Atom</a>、<a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="external">Visual Studio Code</a>），可即時查看 lint 結果，讓開發者更容易檢查語法錯誤。</p>
<h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>本想簡單介紹如何建置一個前端開發環境，無奈前端之龐大，初出茅廬的我，完全無法收斂文章內容。本文已盡量點到為止，在重要之處皆留下關鍵連結，給有興趣的人們挖了些坑，希望看倌透過這篇文章，能對前端工程紛擾的世界有所了解，也不吝指教交流！</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://nodejs.org/api/" target="_blank" rel="external">Node.js API Documentation</a></li>
<li><a href="https://github.com/creationix/nvm" target="_blank" rel="external">NVM - Node Version Manager</a></li>
<li><a href="https://www.npmjs.com/" target="_blank" rel="external">NPM - Node Package manager</a></li>
<li><a href="https://docs.npmjs.com/getting-started#cli" target="_blank" rel="external">NPM Cli Commands</a></li>
<li><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">NPM package.json spec</a></li>
<li><a href="https://developer.mozilla.org/" target="_blank" rel="external">Mozilla Developer Network</a></li>
<li><a href="http://gulpjs.com/" target="_blank" rel="external">Gulp - The streaming build system</a></li>
<li><a href="https://webpack.js.org/" target="_blank" rel="external">Webpack - A bundler for javascript and friends</a></li>
<li><a href="https://mochajs.org/" target="_blank" rel="external">Mocha - Feature-rich Test Framework</a></li>
<li><a href="http://chaijs.com/" target="_blank" rel="external">Chai - BDD/TDD Assertion Library</a></li>
<li><a href="http://eslint.org/" target="_blank" rel="external">ESLint - Pluggable JavaScript Linter</a></li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <span>Weihang Lo</span>
    </p>
    <p class="copyright-item">
      <span>Origin: </span>
      <a href="https://weihanglo.github.io">https://weihanglo.github.io</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://weihanglo.github.io/2017/fed-toolchain/">https://weihanglo.github.io/2017/fed-toolchain/</a>
    </p>

    <p class="copyright-item lincese">
      
      Text is available under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">Creative Commons Attribution-NonCommercial 4.0 International</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/nodejs/">NodeJS</a>
          
            <a href="/tags/javascript/">JavaScript</a>
          
            <a href="/tags/front-end/">Front-End</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/swift-error-handling/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">理解 Swift 的 Error Handling</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2017/carthage-intro/">
        <span class="next-text nav-default">Carthage 套件管理工具</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    
  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:weihanglotw@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
        
          <a href="https://twitter.com/weihanglo" class="iconfont icon-twitter" title="twitter"></a>
        
      
    
      
        
          <a href="https://www.facebook.com/weihanglo" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://github.com/weihanglo" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="https://getpocket.com/@weihanglo" class="iconfont icon-pocket" title="pocket"></a>
        
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Weihang Lo</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://weihanglo.github.io/2017/fed-toolchain/';
        this.page.identifier = '2017/fed-toolchain/';
        this.page.title = 'Front End Development Toolchain';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//weihang-lo.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>




    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.2.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.2.x"></script>

    
  <script type="text/html" id="search-result">
    <article class="post">
      <header class="post-header">
        <h1 class="post-title">
          <a href="$url$" class="post-link">
            $title$
          </a>
        </h1>
      </header>
      <div class="post-content">
        $content$
        <div class="read-more">
          <a href="$url$" class="read-more-link">
            Read more..
          </a>
        </div>
      </div>
    </article>
  </script>
  <script type="text/html" id="no-search-result">
    <div class="no-result">
      <h2>No result found!</h2>
    </div>
  </script>
  <script type="text/javascript" src="/js/src/search.js?v=2.2.x"></script>

  </body>
</html>