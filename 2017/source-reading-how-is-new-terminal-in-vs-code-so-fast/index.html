<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Fira Sans:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Front-end,Source Reading,Canvas,Terminal,Visual Studio Code,Xterm.js," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is “Integrated Terminal performa">
<meta name="keywords" content="Front-end,Source Reading,Canvas,Terminal,Visual Studio Code,Xterm.js">
<meta property="og:type" content="article">
<meta property="og:title" content="Source Reading - How Is New Terminal In VS Code So Fast?">
<meta property="og:url" content="https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/index.html">
<meta property="og:site_name" content="Weihang Lo">
<meta property="og:description" content="Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is “Integrated Terminal performa">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://code.visualstudio.com/opengraphimg/opengraph-blog.png">
<meta property="og:image" content="https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/gecko-rendering-process.png">
<meta property="og:image" content="https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/imagebitmap.png">
<meta property="og:image" content="https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/real-true-color-image.png">
<meta property="og:image" content="https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/fake-true-color-image.png">
<meta property="og:updated_time" content="2017-10-19T14:58:50.559Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Source Reading - How Is New Terminal In VS Code So Fast?">
<meta name="twitter:description" content="Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is “Integrated Terminal performa">
<meta name="twitter:image" content="https://code.visualstudio.com/opengraphimg/opengraph-blog.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/"/>





  <title>Source Reading - How Is New Terminal In VS Code So Fast? | Weihang Lo</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-90000579-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Weihang Lo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">/dev/Weihang</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weihang Lo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://secure.gravatar.com/avatar/67644641ead7ae60a795a14b7e102973">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weihang Lo">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Source Reading - How Is New Terminal In VS Code So Fast?</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-19T22:05:03+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              

              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://code.visualstudio.com/opengraphimg/opengraph-blog.png" alt=""></p>
<p>Last week, a new version (1.17) of Visual Studio Code was released. While there are many fascinating improvements and features introduced, the one that cought my eyes is “Integrated Terminal performance” section. Let’s check out what they’ve done!</p>
<p><em>(written on 2017-10-19, based on Xterm.js v3, VS Code 1.17)</em></p>
<a id="more"></a>
<h2 id="Old-Performance-Issue"><a href="#Old-Performance-Issue" class="headerlink" title="Old Performance Issue"></a>Old Performance Issue</h2><p>The integrated terminal in VS Code is powered by another popular open-source project <a href="https://github.com/sourcelair/xterm.js" target="_blank" rel="external">“Xterm.js”</a>, which is currently maintained by <a href="https://www.sourcelair.com" target="_blank" rel="external">SourceLair</a> and community contributors. There are many real-world use cases of Xterm.js, such as <a href="https://www.rstudio.com/products/RStudio/" target="_blank" rel="external">RStudio</a> and <a href="https://github.com/jupyterlab/jupyterlab" target="_blank" rel="external">JupyterLab</a> (Ah ha! Data scientist!), not to mention SourceLair itself. One can say that Xterm.js dominates web-based terminal world as React does within front-end frameworks.</p>
<p>As same as other web-based HTML terminal emulators, old versions of Xterm.js are powered by old fashion. Rendering from <code>HTMLElement</code>s, selecting text via <code>document.getSelection</code>, receiving DOM <code>MouseEvent</code>s. All these works were done by a sequence of DOM manipulations.</p>
<p>Development in modern web technologies lowers the barriers for other devs to contribute to. Every programmer can easily pick up a JavaScript cookbook to study, then boasts about new frameworks on Github trending as he is a JavaScript expert. However, web techs also brings another significant drawback: performance.</p>
<p>As we mention to web performance, two key concepts should be kept in mind: <strong>reflow</strong> and <strong>repaint</strong>. </p>
<p><img src="gecko-rendering-process.png" alt="Gecko Rendering Process"></p>
<blockquote>
<p>Image from MDN. We focus on <strong>layout</strong> and <strong>paint</strong>.</p>
</blockquote>
<h3 id="Reflow"><a href="#Reflow" class="headerlink" title="Reflow"></a>Reflow</h3><p>When a web page is initialized, the render engine calculates dimensions and position of all elements to layout them in proper place. This is known as <strong>layout</strong>. Although layout is a normal stage of browser rendering process, any updates of position, dimensions or other properties on a specific element after initialization will lead to an additional layout on that element, and all its child nodes need to do a extra layout, too (except nodes with absolute position). These synchronously layout calculations are called <strong>reflows</strong>, which might result in performance bottlenecks. </p>
<blockquote>
<p>Here is a list of <a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" target="_blank" rel="external">what forces layout / reflow</a>. Read it to avoid reflows.</p>
</blockquote>
<h3 id="Repaint"><a href="#Repaint" class="headerlink" title="Repaint"></a>Repaint</h3><p>A <strong>repaint</strong> occurs when changes are made to an element’s visibility, background color, or other styles not relevant to layout. Repaints are less expensive than reflows, but also have some impact on browser reponsive time.</p>
<h3 id="DOM-manipulations-are-slow"><a href="#DOM-manipulations-are-slow" class="headerlink" title="DOM manipulations are slow"></a>DOM manipulations are slow</h3><p>Poor performance is not web techs or JavaScript’s faults. It always counts on implementaion details. <a href="https://hyper.is/" target="_blank" rel="external">Hyper</a> and <a href="https://github.com/railsware/upterm" target="_blank" rel="external">Upterm</a> are two delightful terminal emulators based on Electron. They add many convenient features to improve our boring daily terminal lives. The pain points are their performance issues due to DOM rendering. Both rendering implementations depend on DOM manipulations.</p>
<p>Imagine you are running a <code>yes</code>-like command that writes output at <a href="https://www.reddit.com/r/unix/comments/6gxduc/how_is_gnu_yes_so_fast/" target="_blank" rel="external">full 10.2GiB/s speed</a>. You will find that your web-based terminal emulator stuck and cannot response to any mouse event anymore. The high speed <code>yes</code> triggers trigger a tremendous amount of synchronous <strong>reflows</strong> and <strong>repaints</strong>. Soon, the browser becomes irresponsive.</p>
<h2 id="Optimization-in-Dark-DOM-Era"><a href="#Optimization-in-Dark-DOM-Era" class="headerlink" title="Optimization in Dark DOM Era"></a>Optimization in Dark DOM Era</h2><p>Back to the original version before refactoring to canvas renderer (which started at <a href="https://github.com/sourcelair/xterm.js/commit/c6d4c73c" target="_blank" rel="external">c6d4c73c</a>). VS Code used naïve way to render terminal output. We can simplify the old rendering process into following steps:</p>
<ol>
<li>Setup initial row elements corresponding to each row in terminal. That is to say, if size of the terminal is 80 * 24. It would creates 24 <code>&lt;div&gt;</code> representing each row.</li>
<li>Loops lines from current terminal buffer. Each line is an array of character data. A character data stores its own width and characters information.</li>
<li>Loop character data in each line. Wrap each characters as <code>innerHTML</code> in a <code>&lt;span&gt;</code> element. Remember that we need to escape special character such like <code>&lt;</code>, <code>&gt;</code> and <code>&amp;</code>.</li>
<li>Append <code>&lt;span&gt;</code>s to each row element. Then append each row element to terminal element.</li>
<li>If anything changes, repeat previous steps.</li>
</ol>
<p><strong>What a nightmare!</strong></p>
<p>If you are an experienced web developer, you may feel uncomfortable with all those implementation. Modifying DOM between each updates is highly expensive and leads to janky behavior. Luckily, talented maintainers of Xterm.js found their own solution to improve performance. They</p>
<ul>
<li><a href="https://github.com/sourcelair/xterm.js/blob/c6d4c73c8a8c23ce102918fc0342cf33d2986711/src/Renderer.ts#L159" target="_blank" rel="external">Use <code>DocumentFragment</code> to batch DOM manipulations</a> to reduce DOM reflow/layout.</li>
<li><a href="https://github.com/sourcelair/xterm.js/blob/c6d4c73c8a8c23ce102918fc0342cf33d2986711/src/Renderer.ts#L35" target="_blank" rel="external">Build an object pool</a> to reuse <code>&lt;span&gt;</code> elements containing characters to render. This reduce a plenty of new element creation time.</li>
<li><a href="https://github.com/sourcelair/xterm.js/blob/c6d4c73c8a8c23ce102918fc0342cf33d2986711/src/Renderer.ts#L67-L102" target="_blank" rel="external">Setup a skip-frame mechanism</a> to throttle refresh rate when consuming large streamed buffer. </li>
<li>Implement a <a href="https://github.com/sourcelair/xterm.js/pull/670" target="_blank" rel="external">custom selection logic</a> to support multiple pages selections instead of <code>document.getSelection</code>.</li>
</ul>
<p>Despite that these methods made performance much better (at least better than other popular project I’ve tried), the implementation still had some space for enhancements. For instance,</p>
<ul>
<li>Modification of <code>&lt;span&gt;</code>s in <code>&lt;div&gt;</code> rows still trigger some unnecessary reflows.</li>
<li>The old rendering process will always remove entire line from DOM, and then append new element to DOM, even when only a single character changed. </li>
<li>Though the skip-frame mechanism can free CPU from endless <code>requestAnimationFrame</code> events, the skip-frame itself means dropping frame from 60 FPS animaition.</li>
<li>Most characters used in terminal can represent in ASCII code, but a browser always use UTF-16 <code>DOMString</code> to store the information, which may be seen as a waste of memory usage.</li>
</ul>
<h2 id="Simple-Intro-of-Canvas"><a href="#Simple-Intro-of-Canvas" class="headerlink" title="Simple Intro of Canvas"></a>Simple Intro of Canvas</h2><p><a href="https://code.visualstudio.com/blogs/2017/10/03/terminal-renderer" target="_blank" rel="external">As the recent blog post said</a>, the new canvas-based rendering engine renders 5 to 45 times faster, and reduces input latency, power usage and many more. Sounds perfect! However, not all front-end developers are familiar with canvas API. Here are some basic concepts of canvas API you need to know.</p>
<p>The <code>&lt;canvas&gt;</code> is an HTML element providing API for rendering graphics via scripting (JavaScript) on the fly. Modern browsers would also enable hardware-acceleration of canvas rendering by default. You can think of canvas API as an optimized version of browser’s <strong>repaint</strong> powered by GPU.</p>
<h3 id="API-Provider"><a href="#API-Provider" class="headerlink" title="API Provider"></a>API Provider</h3><p>To render a 2D canvas, one developer just need to follow simple steps shown below:</p>
<ol>
<li>Create a rendering context (by creating a <code>&lt;canvas&gt;</code> element).</li>
<li>Access contexts (use <code>canvas.getContext(&#39;2d&#39;)</code> for 2D rendering context).</li>
<li>Start drawing via <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D" target="_blank" rel="external">various commands</a>.</li>
<li>All drawing results are rendered onto canvas element as an composited image.</li>
</ol>
<p>As you can see, learning 2D canvas rendering needs only a small amount (around 70 API for 2D context) of human memory. Most of these drawing API are style-related. As a web developer, you must have seen more CSS styles than these tiny group of drawing commands. Memorizing 70 additional methods is just a piece of cake, huh?</p>
<h3 id="Resource-Saver"><a href="#Resource-Saver" class="headerlink" title="Resource Saver"></a>Resource Saver</h3><p>Another selling points is that 2D Canvas rendering provides a plenty of <strong>pixel-awared</strong> drawing commands. Instead of updating the whole canvas element, these drawing methods let you decide your region of interset to be re-render in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas" target="_blank" rel="external">per-pixel level</a>. Almost all drawing API provide optional coordinates and size parameters for devs to tweak what they really desire. The process of updating only changed elements is called <strong>invalidation</strong>, and that preserves much precious CPU and GPU time.</p>
<p>As opposed to DOM elements, styles in 2D canvas are shared between each path belongs to the canvas. No need to store inline-styling information for every elements. If you want to temporarily store your style state, you can use the standard <code>context.save()</code> and <code>context.restore()</code> methods to push/pop your styles from a stack-like context state container. That’s why I call canvas a <strong>memory saver</strong>!</p>
<h3 id="Performance-Booster"><a href="#Performance-Booster" class="headerlink" title="Performance Booster"></a>Performance Booster</h3><p>As well as saving resources, canvas rendering also gives us ways to jack up performance. One is using detached canvas as an off-screen canvas or using <code>OffScreenCanvas</code> directly. The latter can even draw canvas in worker threads!</p>
<p>Another way is creating a texture atlas. A <a href="https://en.wikipedia.org/wiki/Texture_atlas" target="_blank" rel="external">texture atlas</a> a.k.a. <strong>sprite sheet</strong>, is an image packed other small pieces of sub-images into itself. When drawing a sub-image, one can picks up the sub-image by its own texture coordinates. The reason to store images in single texture is that GPU is often more performant when accessing a large texture one time than multiple tiny images many times.</p>
<video src="nyancat.mp4" style="width:100%;height:300px" autoplay loop controls></video>

<blockquote>
<p>Nyancat runs on VS Code without janky!</p>
</blockquote>
<h2 id="Canvas-to-the-Rescue"><a href="#Canvas-to-the-Rescue" class="headerlink" title="Canvas to the Rescue"></a>Canvas to the Rescue</h2><p>After understand big concepts in 2D canvas. Let’s dive into <a href="https://github.com/sourcelair/xterm.js/pull/938" target="_blank" rel="external">the pull request</a> that made canvas renderder. First, recap what they’ve done:</p>
<ol>
<li>Texture atlas (use <code>ImageBitmap</code>) for ASCII codes and ANSI 256 colors. Unicode characters and true-colored text would be drawn on the fly.</li>
<li>Only render changes. To determine state changes, use custom <code>GridCache</code> to stoer previous state for comparisons with incoming changes.</li>
<li>Use four different render layers to separate concerns and reduce the whole canvas re-rendering. </li>
<li>Remove skip-frame mechanism because new rendering performance is extremely fast.</li>
</ol>
<h3 id="Texture-Atlas-and-Color-Managements"><a href="#Texture-Atlas-and-Color-Managements" class="headerlink" title="Texture Atlas and Color Managements"></a>Texture Atlas and Color Managements</h3><p>First, we look into the texture atlas.</p>
<p>Xterm.js constructs a global atlas generator shared between terminals with the same configuration (defined in <code>ICharAtlasConfig</code> and <code>ICharAtlasCacheEntry</code>). This can reduces some duplicated construction if an app gets a multiple terminal instances such as VS Code. The actual time that a atlas generated is terminal being opened by calling <code>acquireCharAtlas</code>. Interally, <code>acquireCharAtlas</code> would compare between configurations (font size, char width, color, etc.) to avoid overhead works.</p>
<p>The private class <code>CharAtlasGenerator</code> does the real stuff. It sets attribute <code>alpha</code> to <code>false</code> to reduce redundant transparent compositions. Though this config seen like a limit of flexibility, the texture atlas is enough to provides frequently used colors for most text-based programs in the world. Moreover, the generator draws all ASCII code with 8 ANSI color (3 bit) in normal and bold styles onto an detached canvas in advance. That would be nearly 256 * 16 = 4096 characters pre-rendered (though some char is invisible and not printable). </p>
<p><img src="imagebitmap.png" alt="ImageBitmap"></p>
<blockquote>
<p>That’s how the <code>CharAtlas</code> looks behind the scene.</p>
</blockquote>
<p>All colors you need on your 5-year-old ASUS laptop is here. Whoever needs more characters atlas?</p>
<blockquote>
<p>In the beginning, I found that the CharAtlas generating actually twice (canvas element and ImageBitmap). <a href="https://github.com/sourcelair/xterm.js/pull/938#pullrequestreview-69391070" target="_blank" rel="external">Tyriar told me the intent</a>, what they want to achieve is not only improving the construction performance, but decreasing drawing latency.</p>
</blockquote>
<h3 id="Separating-Render-Layers"><a href="#Separating-Render-Layers" class="headerlink" title="Separating Render Layers"></a>Separating Render Layers</h3><p>Xterm.js separates the canvas rendering into four different layers (ordered from bottom to top):</p>
<ul>
<li><code>TextRenderLayer</code>: Render background and foreground of the content.</li>
<li><code>SelectionRenderLayer</code>: Render only selected region.</li>
<li><code>LinkRenderLayer</code>: Render hyperlink with extra color and text decorator (underline).</li>
<li><code>CursorRenderLayer</code>: Render different style of a blinking cursor.</li>
</ul>
<p>This can gain a performance boost since the render engine only repaint changed parts instead of the whole canvas. While constructing 4 different canvases is awesome, we lost the chance to set canvas’ alpha channel to opaque. This may lead to a performance drop on 2D graphic composition. The compositor requires extra GPU time to composite 4 additional transparent contexts. GUI framework providers always recommend that use opaque layer as possible as we can (at least <a href="https://developer.apple.com/documentation/uikit/uiview/1622622-isopaque" target="_blank" rel="external">iOS UIKit</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext#Parameters" target="_blank" rel="external">Canvas 2D Context</a> said).</p>
<p>In reality, it may not cause any problem if you layer is not opaque. I have not yet done any profiling or tests. Just have a thought on this kind of situation.</p>
<p>On the other side, it is very pleasant to trace a well-organized source code. We do not need to plunge ourselves into each lines if we only want to understand a little part of code. And Xterm.js does this job perfectly. The separation of render layers is an awesome example. The feeling deepens even more when the codebase is written in TypeScript. As a former iOS engineer, the syntax of type annotations are very familiar and helpful to rapidly grasp the big picture of a project for a newcomer. Maybe it’s time to use TypeScript in our next project. Thanks Xterm.js contributors!</p>
<h2 id="Bugs-After-Breaking-Changes"><a href="#Bugs-After-Breaking-Changes" class="headerlink" title="Bugs After Breaking Changes"></a>Bugs After Breaking Changes</h2><p>Canvas renderer is awesome! Canvas renderer is promising! Canvas renderer outperforms all competitors in web-based terminal world! </p>
<p>Is the new renderer really that invulnerable? Maybe not. </p>
<p>Let me introduce some interesting issues after the switch of render engine.</p>
<h3 id="Rendering-Unicode-Characters-Wrong"><a href="#Rendering-Unicode-Characters-Wrong" class="headerlink" title="Rendering Unicode Characters Wrong"></a>Rendering Unicode Characters Wrong</h3><p>When it comes to strings and texts. This may be a big nightmare to all developers. One feature Xterms.js always promoting is handling CJK fonts well. Actually, before introduing canvas renderer, most of this works done by browsers’ DOM render engine internally to handle various widths of Unicode characters. When the team chose to render character on our own renderer, the burden fell on Xterm.js itself. To render texts properly, Xterm.js needs to manually track width of all characters. Explicitly set width of render region is a must. 2D Canvas API is always that imperative and there is no way to stay away from it. </p>
<p>Surprisely, Xterm.js has alreadly done it before canvas render landed! It used a custom data structure to track width of a character for some resizing calculations. The only task after renderer changed is passing the character width into <code>canvas.fillText</code>.</p>
<p>Actually, character width received from terminal input are not always correct. Some characters <a href="https://github.com/Microsoft/vscode/issues/35102" target="_blank" rel="external">consume more space than expected</a>.The truth is Xterm.js extracted some concepts from <a href="https://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c" target="_blank" rel="external">this <code>wcwidth.c</code> implementation</a>. Although the implementation covered almost all CJK and other Unicode chacters with various width, it have not been modified time since 2007. During these 10 years, Emoji become prosperous. Suddenly, oudated <code>wcwidth</code> implementation cannot support arriving crazy overflowing characters.</p>
<p>But Xterm.js team did not feel contented with the situation, and later they <a href="https://github.com/sourcelair/xterm.js/pull/997" target="_blank" rel="external">resolved the issue</a> blazing fast. If you want to know about what they did, there was nothing but <a href="https://github.com/mofux/xterm.js/blob/b3efd7e0fd1e1ebef84cfa05d741a7bbaf9441e4/src/renderer/TextRenderLayer.ts#L207" target="_blank" rel="external">delegating up the responsibility of width calculation</a> to web browsers’ render engine. When calling <code>ctx.measureText</code>, the render engine measures the target text in specific canvas context, then returns a <code>TextMatrix</code> that stores information abount how the text would be rendered, such as <code>width</code>, <code>actualBoundingBoxLeft</code>, and <code>alphabeticBaseline</code>. This implmenetation need not to aquire any Unicode code point mapping beforehand. Just believe that all browsers do it right.</p>
<h3 id="Lack-of-True-Color-Support"><a href="#Lack-of-True-Color-Support" class="headerlink" title="Lack of True Color Support"></a>Lack of True Color Support</h3><p>As hardware advanced, true color terminal programs are more common nowadays. The lack of real true color support become a major problems of Xterm.js. I haven’t trace to intent why the original Xterm.js supported only ANSI 256 color, but it makes sense that canvas renderder does not support true color. </p>
<p>There is a class <code>ColorManager</code> which constructs ANSI 256 color to hex color mapping table beforehand in Xterm.js v3. This eliminates dupe computations of each hex color. However, If we want to store all the true color palette, that would be combinations of 3 color channels (RGB) mutiplying alpha channel, which approximately equal to 16 million of combinations! It’s impossible to store that huge <code>CharAtlas</code> in memory simultaneously.</p>
<p>Thus, they use a hacky way (in <a href="https://github.com/sourcelair/xterm.js/blob/2e8410da4bf4ccc44b7277ec22a0d473565c9d13/src/Terminal.ts#L2146-L2230" target="_blank" rel="external">Terminal.ts</a>) to make colors look like true color. The goal of this algorithm is to find the nearest color in ANSI 256 color palette. While we try <a href="https://gist.github.com/XVilka/8346728" target="_blank" rel="external">some real tests</a> on it, wes still can tell the differences without doubt. Some matching results are even so worse that they almost look like inverted colors. Many open-source projects depended on Xterm.js are eager for true color supports, including famous terminal app <a href="https://github.com/zeit/hyper/issues/2294" target="_blank" rel="external">Hyper</a>. However, it seems that supports for true color is not the primary goal and has been remove from v3 milestons, but <a href="https://github.com/sourcelair/xterm.js/issues/484" target="_blank" rel="external">the related discussion on Github</a> is still valuable to take a look.</p>
<p><img src="real-true-color-image.png" alt="Real True Color Image"></p>
<blockquote>
<p>The <strong>REAL</strong> true color in <a href="https://github.com/jwilm/alacritty" target="_blank" rel="external">Alacritty</a>.</p>
</blockquote>
<p><img src="fake-true-color-image.png" alt="Fake True Color Image"></p>
<blockquote>
<p>The <strong>quasi-</strong>true color in VS Code 1.17.</p>
</blockquote>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>It is very lucky see that a widely used library is brave enough to make breaking changes. When I followed up the PR to read source code of Xterm.js, I almost believed that I were working with those brilliant contributors. The experience of tracing a well documented refactor process is awesome. You can learn from some surprsing solutions you have never thought before. You can also learn many communicating skills in open source world. Although canvas API is not the latest web standard and Xterm.js is not a well-known project compared with React and Vue, the success of Xterm.js’s renderer refactor is worthy for learning!</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    Weihang Lo
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/" title="Source Reading - How Is New Terminal In VS Code So Fast?">https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/front-end/" rel="tag"># Front-end</a>
          
            <a href="/tags/source-reading/" rel="tag"># Source Reading</a>
          
            <a href="/tags/canvas/" rel="tag"># Canvas</a>
          
            <a href="/tags/terminal/" rel="tag"># Terminal</a>
          
            <a href="/tags/visual-studio-code/" rel="tag"># Visual Studio Code</a>
          
            <a href="/tags/xterm-js/" rel="tag"># Xterm.js</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/binary-data-manipulations-in-javascript/" rel="next" title="Binary Data Manipulations in JavaScript">
                <i class="fa fa-chevron-left"></i> Binary Data Manipulations in JavaScript
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="https://secure.gravatar.com/avatar/67644641ead7ae60a795a14b7e102973"
              alt="Weihang Lo" />
          
            <p class="site-author-name" itemprop="name">Weihang Lo</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/weihanglo" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/weihanglo" target="_blank" title="Facebook">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/weihanglo" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://getpocket.com/@weihanglo" target="_blank" title="Pocket">
                  
                    <i class="fa fa-fw fa-get-pocket"></i>
                  
                    
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Old-Performance-Issue"><span class="nav-text">Old Performance Issue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflow"><span class="nav-text">Reflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Repaint"><span class="nav-text">Repaint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM-manipulations-are-slow"><span class="nav-text">DOM manipulations are slow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optimization-in-Dark-DOM-Era"><span class="nav-text">Optimization in Dark DOM Era</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Simple-Intro-of-Canvas"><span class="nav-text">Simple Intro of Canvas</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-Provider"><span class="nav-text">API Provider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource-Saver"><span class="nav-text">Resource Saver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance-Booster"><span class="nav-text">Performance Booster</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Canvas-to-the-Rescue"><span class="nav-text">Canvas to the Rescue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Texture-Atlas-and-Color-Managements"><span class="nav-text">Texture Atlas and Color Managements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Separating-Render-Layers"><span class="nav-text">Separating Render Layers</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bugs-After-Breaking-Changes"><span class="nav-text">Bugs After Breaking Changes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rendering-Unicode-Characters-Wrong"><span class="nav-text">Rendering Unicode Characters Wrong</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lack-of-True-Color-Support"><span class="nav-text">Lack of True Color Support</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Summary"><span class="nav-text">Summary</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weihang Lo</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://weihang-lo.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://weihanglo.github.io/2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/';
          this.page.identifier = '2017/source-reading-how-is-new-terminal-in-vs-code-so-fast/';
          this.page.title = 'Source Reading - How Is New Terminal In VS Code So Fast?';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://weihang-lo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  










  





  

  

  

  

  

  

</body>
</html>
