<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavaScript,Front-end,Concurrency,Async Function,Generator," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solutio">
<meta name="keywords" content="JavaScript,Front-end,Concurrency,Async Function,Generator">
<meta property="og:type" content="article">
<meta property="og:title" content="Modern Concurrency in JavaScript - Async Functions">
<meta property="og:url" content="https://weihanglo.github.io/2017/javascript-concurrency-async-function/index.html">
<meta property="og:site_name" content="Weihang Lo">
<meta property="og:description" content="在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solutio">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2017-08-12T12:25:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Modern Concurrency in JavaScript - Async Functions">
<meta name="twitter:description" content="在前一篇介紹 JavaScript Concurrency 的文章中，Promise 提供開發者安全統一的標準 API，透過 thenable 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solutio">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://weihanglo.github.io/2017/javascript-concurrency-async-function/"/>





  <title>Modern Concurrency in JavaScript - Async Functions | Weihang Lo</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-90000579-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Weihang Lo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">/dev/Weihang</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weihanglo.github.io/2017/javascript-concurrency-async-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Weihang Lo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weihang Lo">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Modern Concurrency in JavaScript - Async Functions</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-18T12:45:34+08:00">
                2017-06-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/javascript-concurrency-async-function/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/javascript-concurrency-async-function/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              

              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  16
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在前一篇介紹 <a href="https://weihanglo.github.io/2017/javascript-concurrency-promise/">JavaScript Concurrency 的文章</a>中，Promise 提供開發者安全統一的標準 API，透過 <code>thenable</code> 減少 callback hell，巨幅降低開發非同步程式的門檻，大大提升可維護性。不過，Promise 仍沒達到 JS 社群的目標「Write async code synchronously」。本篇文章將簡單最新的 Concurrency Solution「Async Functions」，利用同步的語法寫非同步的程式，整個人都變潮了呢！</p>
<p><em>（撰於 2017-06-17，基於 ECMAScript 7+）</em></p>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="external">Async Functions</a> 在去年進入 Stage 4，正式成為 ECMAScript 7 標準，這對 JS 社群無疑是一大利多。截至目前為止（2017.6），實作 Async Functions 的環境有：</p>
<ul>
<li>Node.js 7.6.0 (without <code>--harmony</code>)</li>
<li>Chrome 55</li>
<li>Firefox 52</li>
<li>Safari 10.1</li>
<li>Edge 15</li>
</ul>
<p>可以看到<a href="http://caniuse.com/#search=async%20functions" target="_blank" rel="external">當前 Release 版的 Desktop browser 都可以用了</a>。</p>
<p>從此我們不會在 callback hell 中迷失自我，不需在 <code>then</code> 中塞一堆 <code>console.log</code>，也不需使用蹩足的 generator 語法。ES7 的 <code>async function</code> 完成我們對非同步程式的想像。</p>
<p><strong>真的有這麼好康嗎？</strong></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="external">MDN</a> 點出 async function 的定位。</p>
<blockquote>
<p>The purpose of async/await functions is to simplify the behavior of using promises synchronously and to perform some behavior on a group of Promises. Just like Promises are similar to structured callbacks, async/await is similar to combining generators and promises.</p>
</blockquote>
<p>Async functions 的目的在於簡化多個 promise 操作，不需要再串聯一堆 <code>then</code>。如果我們將 Promises 比喻為好讀版的 callbacks，那 async／await 就是 generator + promise 的綜合體，因此，<strong>我們仍需學習 promise 以及 generator 等概念</strong>。</p>
<p>話不多說，一起快速了解 generator 吧！</p>
<h2 id="Generator-With-Async-Operations"><a href="#Generator-With-Async-Operations" class="headerlink" title="Generator With Async Operations"></a>Generator With Async Operations</h2><p>在 async／await 還沒出世之前，generator function 是非同步程式設計的最新潮的替代品，TJ 的 <a href="https://github.com/tj/co" target="_blank" rel="external">co</a> 與 Facebook 的 <a href="https://github.com/facebook/regenerator" target="_blank" rel="external">regenerator</a> 這兩個 libraries 都擁有高人氣。藉由 <a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="external">Coroutine（協程）</a> suspend／resume 的機制，讓開發非同步 JS 可以避開多線程煩人的 context-switch、dead lock，能用很直觀的方式撰寫程式。當然，coroutine 仍是在同個 thread 上面執行，並非真實的 parallel computing，不過 browser 這種常出現 I／O 的場景中，coroutine 已綽綽有餘了。</p>
<p><strong>我只是想了解 async function 怎麼用，為什麼還要學 coroutine 和 generator？不會太複雜嗎？</strong></p>
<p>別緊張，接下來將淺淺帶過 generator 概念。本人同樣不喜歡 generator 醜陋的 <code>*</code>，<code>*</code> 只該留給最愛的 pointer。介紹 generator 之前，先來了解 ES6 的 <strong>Iterable</strong> 與 <strong>Iterator</strong> 吧 XD！（不是說好快速瞭解 generator 嗎⋯⋯）</p>
<h3 id="Iterable-amp-Iterator"><a href="#Iterable-amp-Iterator" class="headerlink" title="Iterable &amp; Iterator"></a>Iterable &amp; Iterator</h3><p>ES6 除了引入標準的 <code>Promise</code> object 以外，另一重大的語法變革就是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">Iterator</a> 與 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">Generator</a>。熟悉 C++、Swift、Java 或 Python 3 的朋友應該非常熟悉 iterable／iterator 等名詞。在 JavaScript中，名詞解釋大致如下：</p>
<ul>
<li><strong>iterable</strong> 是指可迭代的物件，也就是可丟進 loop 運作的物件，會產生 <strong>iterator</strong>，但不一定是 <a href="https://en.wikipedia.org/wiki/Sequence" target="_blank" rel="external">sequence</a> 或 <a href="https://en.wikipedia.org/wiki/Container_(abstract_data_type)" target="_blank" rel="external">container</a>。</li>
<li><strong>iterator</strong> 就是鼎鼎大名的迭代器，如同指針般迭代東西（通常是 <strong>iterable</strong> 提供的值）。</li>
</ul>
<p>日常會遇到的 iterable 應該會長這樣：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> obj <span class="keyword">of</span> iterable) &#123;&#125;</div><div class="line">iterable.forEach()</div><div class="line">iterable.map()</div></pre></td></tr></table></figure>
<p>這些 <strong>iterable</strong> 有共通特性，就像下面的 list 一樣又臭又長。</p>
<ul>
<li>有一個 <code>[Symbol.iterator]</code> method，<ul>
<li><code>[Symbol.iterator]</code> 會回傳一個 <strong>iterator</strong> object，<ul>
<li><strong>iterator</strong> 上要有 <code>next</code> method，<ul>
<li><code>next</code> method 會回傳一個 object 記錄 iteration 當前狀態，其有兩個 property，<ul>
<li><code>done</code>：當次 iteration 是否結束的 boolean flag</li>
<li><code>value</code>：當次 iteration 的 return value</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看了這種 nested list，是不是眼睛都茫了，想立馬關掉這篇廢文呢？別怕，常用的 <code>Array</code> 和 ES6 的 <code>Map</code>、<code>Set</code> 等都是內建的 iterable，我們不需自己辛苦實作；而 plain <code>Object</code> 雖非 iterable，但也有 <code>Object.entries</code> 等方法供我們轉換成 iterable 呢。</p>
<p>我們來看一個簡單 Iterator 實作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> infiniteLoop = &#123;&#125;</div><div class="line">infiniteLoop[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 實作 iterator 建構 funtion</span></div><div class="line">  <span class="keyword">let</span> v = <span class="number">0</span></div><div class="line">  <span class="keyword">return</span> &#123; <span class="comment">// 回傳有 `next` method 的 object</span></div><div class="line">    next: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="comment">// 回傳記錄當前 iteration state 的 object</span></div><div class="line">      value: ++v,</div><div class="line">      done: <span class="literal">false</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 無限迴圈</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> infiniteLoop) &#123;</div><div class="line">  <span class="built_in">console</span>.log(v)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>有興趣了解相關 protocols，可以<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="external">看此</a>。</p>
</blockquote>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>上一節最後，我們從頭打造了一個 Iterator，看起來十分不易，其實 iterator 實作繁瑣，是每種語言皆然，<a href="https://stackoverflow.com/a/7542261" target="_blank" rel="external">連 Python 3 也不例外</a>，於是，<strong>generator</strong> 就誕生了。 Generator 基於 iterator 概念之上，利用<del>簡單明瞭</del>的語法，讓建構 iterator 不必這麼痛苦。我們將前一節的例子改成 generator 試試看。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genFunc</span> (<span class="params"></span>) </span>&#123; <span class="comment">// `*` 宣告一個 generator function，即是 iterator factory</span></div><div class="line">  <span class="keyword">let</span> v = <span class="number">0</span></div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> ++v <span class="comment">// generator function 的 body 內才能使用 `yield` keyword</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 無限迴圈</span></div><div class="line"><span class="keyword">const</span> g = genFunc() <span class="comment">// 產生一個 iterator</span></div><div class="line"><span class="keyword">let</span> v = g.next() <span class="comment">// 取得 iterator 下一個 state</span></div><div class="line"><span class="keyword">while</span> (!v.done) &#123;</div><div class="line">  <span class="built_in">console</span>.log(v.value)</div><div class="line">  v = g.next()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>乍看之下，似乎沒比 iterator 簡單，而且又多了 <code>function*</code> 和 <code>yield</code>，是要嚇死人嗎？這裡的重點並非語法，而是一開始提及的 <a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="external">Coroutine</a>概念。這種 coroutine 的概念與一般逐行執行的程式不同，運作流程如下：</p>
<ol>
<li>執行到 <code>yield</code>，暫停。</li>
<li>將執行權交給外部，等待外部 call <code>next</code>。</li>
<li>外部 call <code>next</code>，回到步驟一繼續執行。</li>
</ol>
<p>套在我們的例子中，就是：</p>
<ul>
<li>當每次 <code>genFunc</code> 執行到 <code>yield</code> 時，會停下來，</li>
<li>將程式執行權交給外部 caller，</li>
<li>等到外部調用者再次 call <code>next</code> method，<code>genFunc</code> 再接著執行。</li>
</ul>
<p>簡而言之，<strong>「Generator 是 coroutine 的一種形式，是一個 pause／resume 的執行流程」</strong>。但這樣到底與非同步程式設計有啥鬼關係？</p>
<p>重點在於「透過 coroutine 將程式執行權交給外部 caller」，這可好玩了，如果我們讓 <code>yield</code> 返回一個 promise，程式執行權就會回到 caller 上，而 caller 不僅有程式執行權，可以執行其他程式片段，也可以取得非同步操作的結果。想像中的程式碼長這樣：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 想像中的程式碼</span></div><div class="line"><span class="comment">// fetch 是一個 promise-based 非同步 function</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncFunc</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> fetch(<span class="string">'a'</span>)</div><div class="line">  <span class="built_in">console</span>.log(a)</div><div class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> fetch(<span class="string">'b'</span>)</div><div class="line">  <span class="built_in">console</span>.log(b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看起來非常驚人！可惜這是虛擬的程式碼，<code>a</code>、<code>b</code> 都是一個 Promise，需要利用 <code>then</code> method 取得 resolve value。不過，JS 社群當然不會放過 generator 這個裝逼的好工具，大神們透過各種奇淫巧技，讓我得以利用 generator 優美地寫出 synchronously asynchronous code，以下這個例子便是透過 <code>spawn</code> 自動執行 <code>next</code> 的 helper function 達成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Helper Function</span></div><div class="line"><span class="comment">// from: Jake Archibald - JavaScript Promises: an Introduction</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span> (<span class="params">generatorFunc</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">continuer</span> (<span class="params">verb, arg</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      result = generator[verb](arg)</div><div class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (result.done) &#123;</div><div class="line">      <span class="keyword">return</span> result.value</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(result.value).then(onFulfilled, onRejected)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> generator = generatorFunc()</div><div class="line">  <span class="keyword">var</span> onFulfilled = continuer.bind(continuer, <span class="string">'next'</span>)</div><div class="line">  <span class="keyword">var</span> onRejected = continuer.bind(continuer, <span class="string">'throw'</span>)</div><div class="line">  <span class="keyword">return</span> onFulfilled()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 利用 spawn 包裹，自動執行 generator function</span></div><div class="line"><span class="comment">// 這是一個 sequential(serial) operation</span></div><div class="line">spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> fetch(<span class="string">'a'</span>) <span class="comment">// 等待 fetch('a')，並將結果 assign to a</span></div><div class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// a 是一個</span></div><div class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> fetch(<span class="string">'b'</span>) <span class="comment">// 等待 fetch('b')，並將結果 assign to b</span></div><div class="line">  <span class="built_in">console</span>.log(b)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>這就是 async generator 的實作，很美，但過程十分嚇人。</p>
<blockquote>
<p>Note：Coroutine（協程）比較明確的定義是，指執行權從一個 coroutine 交至另外一個 coroutine，不過概念上類似，這裡借用一下，特此說明。</p>
</blockquote>
<h2 id="Debut-of-Async-Functions"><a href="#Debut-of-Async-Functions" class="headerlink" title="Debut of Async Functions"></a>Debut of Async Functions</h2><p>使用上面這些燒腦的東西，雖達成任務，不過太疊床架屋，抽象概念難以消化。這時候就該主角 <strong>Async Function</strong> 登場！可以將 async functions 想像為 generator + promise，不過更直接的講法是：<strong>「Async Function 是內置 <code>spawn</code> 的 generator function」</strong>。</p>
<p>接下來，將前面使用 <code>spawn</code> 執行的 generator function 改寫成 async function。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 利用 `async` keyword 宣告 一個 async function</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> a = <span class="keyword">await</span> fetch(<span class="string">'a'</span>) <span class="comment">// 使用 `await` 等待 fetch('a')，並將結果 assign to a</span></div><div class="line">  <span class="built_in">console</span>.log(a)</div><div class="line">  <span class="keyword">const</span> b = <span class="keyword">await</span> fetch(<span class="string">'b'</span>) <span class="comment">// 使用 `await` 等待 fetch('b')，並將結果 assign to b</span></div><div class="line">  <span class="built_in">console</span>.log(b)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 執行 async function，不需自己寫 `spawn`，如同正常的 function call。</span></div><div class="line">run()</div></pre></td></tr></table></figure>
<p>Async functions 使用語意清楚的 <code>async</code>／<code>await</code> 取代 <code>function*</code>／<code>yield</code>，除此之外，幾乎與 generator 版本一模一樣。其差異如下：</p>
<ul>
<li>不需額外的 helper function 來執行，一般的 function call 即可。</li>
<li>回傳值為 promise。（相比於 generator 回傳 iterator，async function 復用／組合性較高）</li>
</ul>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>使用方法如下，非常簡單：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myAsyncFunc</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> result</div><div class="line">  <span class="keyword">try</span> &#123; <span class="comment">// 慣例使用 try-catch 處理錯誤</span></div><div class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> fetchA() <span class="comment">// async operation</span></div><div class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> fetchB() <span class="comment">// async operation</span></div><div class="line">    result = &#123;a, b&#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// 將 error 吃掉</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`Error occurred: <span class="subst">$&#123;e&#125;</span>`</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h3><p><code>await</code> 是用來等待 Promise resolution 的運算子，語法與特性如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">[rv] = <span class="keyword">await</span> expression</div><div class="line"><span class="comment">// rv -&gt; return value of await expression</span></div></pre></td></tr></table></figure>
<ul>
<li>僅能用在 async function 內部。</li>
<li>expression 若是 promise 以外的 value，直接返回該 value</li>
<li>expression 若接 promise object，則等待該 promise resolution。<ul>
<li>若 promise fulfilled，直接返回該 value。</li>
<li>若 promise rejected，拋出 Error 到 async function context 中（不被 promise 本身吃掉）。</li>
</ul>
</li>
</ul>
<p>這裡要注意的是，<code>await</code> 會等待 promise resolution 後才 return value，所以行為與 synchronous code 一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// async arrow function</span></div><div class="line"><span class="keyword">const</span> fun = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve()</div><div class="line">  <span class="comment">// 等待 a 處理完畢，再往下執行</span></div><div class="line">  <span class="keyword">const</span> b = <span class="keyword">await</span> a.process()</div><div class="line">  <span class="comment">// 等待 b 處理完畢，再往下執行</span></div><div class="line">  <span class="keyword">const</span> c = <span class="keyword">await</span> b.process()</div><div class="line">  <span class="comment">// 返回最終的結果 c</span></div><div class="line">  <span class="keyword">return</span> c</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Return-Value"><a href="#Return-Value" class="headerlink" title="Return Value"></a>Return Value</h3><p>我們知道，Async function 的 return value 會是一個 promise，那這個 promise 什麼時候會 fulfill，什麼時候會被 reject 呢？</p>
<p>情況其實不複雜，整理如下：</p>
<ol>
<li><code>return</code> 語句會使 async function 直接 resolve，不再往下執行。<ul>
<li>若 <code>return</code> 一個 promise，則以該 promise 為 return value。</li>
<li>若 <code>return</code> 一個非 promise 的 value，則以 <code>Promise.resolve</code> 包裹該 value。</li>
</ul>
</li>
<li>function context 內部拋出任何 <strong>error</strong>，都會直接 reject，不再往下執行。</li>
</ol>
<p>舉幾個簡單例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 直接拋出 Error</span></div><div class="line"><span class="comment">// Return 的 promise 是 rejected 狀態</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">throwDirectly</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rejected!'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 從 await 表達式中拋出錯誤</span></div><div class="line"><span class="comment">// await 會把 promise 中的 error 向外傳遞到 async function context 中</span></div><div class="line"><span class="comment">// Return 的 promise 是 rejected 狀態</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">throwFromAwait</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rejected!'</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 透過 try-catch 處理錯誤，錯誤不繼續傳遞</span></div><div class="line"><span class="comment">// Return 的 promise 不會被 reject</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleError</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Rejected!'</span>))</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="comment">// Explicitly swallow errors</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`Got error: <span class="subst">$&#123;e&#125;</span>`</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 利用其他流程控制語句，達到 early return 的效果</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">earlyReturn</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (someRuleFulfill) &#123;</div><div class="line">    <span class="comment">// 直接 return value，外部會收到 `Promise.resolve('Return Value')`</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Return Value'</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 由於原本即是 return a promise，所以不需使用 `await` 等待結果</span></div><div class="line">  <span class="comment">// No need to: `return await heavyAsyncProcess()`</span></div><div class="line">  <span class="keyword">return</span> heavyAsyncProcess()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看完範例，我們可以得知 Async function 的錯誤處理模式與一般的 function 如出一轍，即「由 context 的執行情形來決定何時 return，何時該 throw Error」。</p>
<p>另外，Async function 的 return value 與 Error 傳到 caller context 時會以 promise 包裹。不會讓整個 call frame 掛掉，但也如同 promise 對錯誤比較 silent，所以再次提醒，慣例會在 async function 內部透過 <strong>try-catch</strong> 處理錯誤，不讓錯誤傳遞過遠，好比 promise 最後必會掛個 catch 處理錯誤。</p>
<h3 id="Declarations"><a href="#Declarations" class="headerlink" title="Declarations"></a>Declarations</h3><p>Async function 既然是 function，想必有許多不同的宣告方式，在此將常用的方式列出來。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// function declaration</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// IIFE (Immediately Invoked Function Expression)</span></div><div class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/* ... */</span>&#125;())</div><div class="line"></div><div class="line"><span class="comment">// ES6 Arrow Function</span></div><div class="line"><span class="keyword">const</span> myAsync = <span class="keyword">async</span> () =&gt; &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// An object props</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="keyword">async</span> myAsync () &#123;&#125;,</div><div class="line">  otherProp: <span class="number">1234</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// A method of a class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line">  <span class="keyword">async</span> myAsync () &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h2><h3 id="Sequential-Operation"><a href="#Sequential-Operation" class="headerlink" title="Sequential Operation"></a>Sequential Operation</h3><p>還記得<a href="https://weihanglo.github.io/2017/javascript-concurrency-promise/">上一篇文章</a>，我們利用 <code>Array#reduce</code> 與 <code>Array#forEach</code> 實作 serial operation 嗎？雖然 promise + functional programming 看起來很有逼格，但又多了一層抽象理解層次。藉由 async function  <code>await</code> 的特性，我們可以寫出很直觀 sequential operations，避開那些 hack。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 直觀的同步操作，每個 await 皆會等 promise resolution 再往下執行</span></div><div class="line"><span class="keyword">const</span> processInSequence = <span class="keyword">async</span> (url) =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> resA = <span class="keyword">await</span> getAsyncResult(<span class="string">'a'</span>)</div><div class="line">  <span class="keyword">const</span> resB = <span class="keyword">await</span> getAsyncResult(<span class="string">'b'</span>)</div><div class="line">  <span class="keyword">return</span> &#123;resA, resB&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>透過 <code>for</code> loop，也可達成 sequential 的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 利用 for loop，iterate 所有 url，逐一等待 promise resolution</span></div><div class="line"><span class="keyword">const</span> fetchInSequence = <span class="keyword">async</span> urls =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> result = []</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> url <span class="keyword">of</span> urls) &#123;</div><div class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(url)</div><div class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> res.json()</div><div class="line">    result.push(json)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Parallel-Operation"><a href="#Parallel-Operation" class="headerlink" title="Parallel Operation"></a>Parallel Operation</h3><p>如果 <code>await</code> 會阻塞該 context（正確說來是轉移執行權），那我如何設計 parallel operation 呢？</p>
<p>非常簡單，那就提前讓 promise 開始執行嘛！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 平行執行兩個 promise</span></div><div class="line"><span class="keyword">const</span> operationInParallel = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="comment">// 不加 await，一次執行兩個 promise</span></div><div class="line">  <span class="keyword">const</span> pA = getAsyncResult(<span class="string">'a'</span>)</div><div class="line">  <span class="keyword">const</span> pB = getAsyncResult(<span class="string">'b'</span>)</div><div class="line">  <span class="comment">// 加上 await，耐心等待 promise 的結果</span></div><div class="line">  <span class="keyword">const</span> resA = <span class="keyword">await</span> pA</div><div class="line">  <span class="keyword">const</span> resB = <span class="keyword">await</span> pB</div><div class="line">  <span class="keyword">return</span> [resA, resB]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自幹兩個 promises 很不直觀？不然我們改用 <code>Promise.all</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 使用 Promise.all await 多個 promises</span></div><div class="line"><span class="keyword">const</span> promiseAllInParallel = <span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</div><div class="line">    getAsyncResult(<span class="string">'a'</span>),</div><div class="line">    getAsyncResult(<span class="string">'b'</span>)</div><div class="line">  ])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>蛤！<code>Promise.all</code> 又出現了！使用 async function 不就是為了拋棄 promise 嗎？很抱歉，在有更清楚的語言特性出現前，只能選擇這種方式，畢竟 async funciton 整個 tech stack 就是建立於 promise 之上。</p>
<p>如果是多個 promise，也可以利用 <code>Array#map</code> 建立新的 context（function scope）來實作 parallel operation，這種方式看起來也稍微 hack，不過仍是本著 async function 的概念。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 利用 `Array#map` 實作 parallel operations</span></div><div class="line"><span class="keyword">const</span> fetchInParallel = <span class="keyword">async</span> urls =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> jsonPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123; <span class="comment">// 建立新的 async function context</span></div><div class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(rul) <span class="comment">// await 只會在這個 context 內等待</span></div><div class="line">    <span class="keyword">return</span> res.json()</div><div class="line">  &#125;)</div><div class="line">  <span class="comment">// 我們可以按順序地印出結果</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> jsonPromise <span class="keyword">of</span> jsonPromises) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> jsonPromise) <span class="comment">// 等待個別 promise resolution</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>想模擬 <code>Promise.race</code>，該如何實作？就直接用 <code>Promise.race</code> 吧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> getFirstResolutionInParallel = <span class="keyword">async</span> urls =&gt; &#123;</div><div class="line">  <span class="comment">// 利用 Promise.race 取得第一個 resolution (either reject or fulfill) 的 promise</span></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race(urls.map(<span class="keyword">async</span> url =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(url)</div><div class="line">    <span class="keyword">return</span> res.json()</div><div class="line">  &#125;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="First-Fulfillment"><a href="#First-Fulfillment" class="headerlink" title="First Fulfillment"></a>First Fulfillment</h3><p>在前一篇 Promise 文章中，我們 invert <code>onRejected</code> <code>onFulfilled</code> 兩個 callback，取得首個 fullfillment result。那在 async function 該如何實作呢？</p>
<p>當然，我們可以直接拿 Promise 做一樣的事，不過時代在走，人要進步，讓我們嘗試使用 <code>try-catch</code> 吧！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// from Stackoverflow https://stackoverflow.com/a/39941616</span></div><div class="line"><span class="keyword">const</span> invert = <span class="function"><span class="params">p</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> p.then(rej, res))</div><div class="line"></div><div class="line"><span class="comment">// 利用 try catch 實作 get first fullfillment（但仍須借助 Promise 的 API）</span></div><div class="line"><span class="keyword">const</span> firstFulfillmentInParallel = <span class="keyword">async</span> urls =&gt; &#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</div><div class="line">      urls.map(<span class="keyword">async</span> url =&gt; &#123;</div><div class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(url)</div><div class="line">        <span class="keyword">return</span> res.json()</div><div class="line">      &#125;).map(invert)</div><div class="line">    )</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="keyword">return</span> e <span class="comment">// 直接返回 inversion 的 fulfillment</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>雖然有達到目的，但 fulfillment 卻是從 <code>catch</code> block 返回，實作漸漸不直觀了。</p>
<h2 id="Async-Interation"><a href="#Async-Interation" class="headerlink" title="Async Interation"></a>Async Interation</h2><p>我們知道，async function 原理上是 generator 的 syntax sugar，利用 iterator 與 <code>yield</code> 轉換控制權，達成 asynchronous operation 效果，但是 <code>iterator.next</code> 這個 method 卻只有 synchronous 版本，有些場景（例如 streaming）需要非同步的 iterator 來取得 streaming data，這時候就該 <strong>async interator</strong> 出場了。</p>
<p><a href="https://github.com/tc39/proposal-async-iteration" target="_blank" rel="external">這個提議</a>目前已在 Stage 3 了，即將納入標準，可以開始瞭解它了。</p>
<p>話不多說，附上提議的範例程式碼，感受一下吧！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// for-await-of loop</span></div><div class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> line <span class="keyword">of</span> readLines(filePath)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(line);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Async generator functions</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">readLines</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> file = <span class="keyword">await</span> fileOpen(path);</div><div class="line"></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (!file.EOF) &#123;</div><div class="line">      <span class="keyword">yield</span> <span class="keyword">await</span> file.readLine();</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">await</span> file.close();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h2><p>比起 promises，async functions 相對沒這麼多文獻供參考，想要入門，依然推薦阮大大的 <a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="external">ECMAScript 6 入门：async 函数</a>，真的是非常豐富的 ES6 大全。當然，<a href="https://developers.google.com/web/fundamentals/getting-started/primers/async-functions" target="_blank" rel="external">Google Web Fundamentals</a> 也值得一看，但沒有 Promise 篇含金量這麼高就是了。</p>
<p>Medium 上也有許多作者在評論 async functions，<a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="external">Hacker Noon 這篇推坑文</a>比較了 promise 與 async function 的優劣，算是蠻清楚的入門文，看看 async function 是否符合妳的期待。另外，也有人寫了不少篇<del>批判</del>反思 async function 的文章，<a href="https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8" target="_blank" rel="external">這篇告訴你還是需要理解 promise</a> 才能以正確的姿勢使用 async／await，另一篇則告訴你，<a href="https://medium.com/@bluepnume/even-with-async-await-you-probably-still-need-promises-9b259854c161" target="_blank" rel="external">promise 還是比較厲害</a>的啦。</p>
<p>當然，沒有任何 unit tests，就算程式碼可讀性再高，仍然非常脆弱，所以，別花太多時間看這些新技術，乖乖地補上缺漏的 tests 比較實在 XD。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://developer.mozilla.org/" target="_blank" rel="external">Mozilla Developer Network</a></li>
<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/async-functions" target="_blank" rel="external">Google Web Fundamentals: Async functions - making promises friendly</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/generator-async" target="_blank" rel="external">ECMAScript 6 入门：Generator 函数的异步应用</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="external">ECMAScript 6 入门：async 函数</a></li>
<li><a href="https://medium.com/@bluepnume/learn-about-promises-before-you-start-using-async-await-eb148164a9c8" target="_blank" rel="external">Daniel Brain: Understand promises before you start using async/await</a></li>
<li><a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" target="_blank" rel="external">Haker Noon: 6 Reasons Why JavaScript’s Async/Await Blows Promises Away</a></li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    Weihang Lo
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="https://weihanglo.github.io/2017/javascript-concurrency-async-function/" title="Modern Concurrency in JavaScript - Async Functions">https://weihanglo.github.io/2017/javascript-concurrency-async-function/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># JavaScript</a>
          
            <a href="/tags/front-end/" rel="tag"># Front-end</a>
          
            <a href="/tags/concurrency/" rel="tag"># Concurrency</a>
          
            <a href="/tags/async-function/" rel="tag"># Async Function</a>
          
            <a href="/tags/generator/" rel="tag"># Generator</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/javascript-concurrency-promise/" rel="next" title="Modern Concurrency in JavaScript - Promises">
                <i class="fa fa-chevron-left"></i> Modern Concurrency in JavaScript - Promises
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/days-with-internet-explorer/" rel="prev" title="與 IE 相處的日子">
                與 IE 相處的日子 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <p class="site-author-name" itemprop="name">Weihang Lo</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/weihanglo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/weihanglo" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/weihanglo" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generator-With-Async-Operations"><span class="nav-text">Generator With Async Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterable-amp-Iterator"><span class="nav-text">Iterable & Iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generator"><span class="nav-text">Generator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Debut-of-Async-Functions"><span class="nav-text">Debut of Async Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Usage"><span class="nav-text">Usage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Await"><span class="nav-text">Await</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Return-Value"><span class="nav-text">Return Value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Declarations"><span class="nav-text">Declarations</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advanced-Usage"><span class="nav-text">Advanced Usage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sequential-Operation"><span class="nav-text">Sequential Operation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel-Operation"><span class="nav-text">Parallel Operation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise-race"><span class="nav-text">Promise.race</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#First-Fulfillment"><span class="nav-text">First Fulfillment</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Async-Interation"><span class="nav-text">Async Interation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Further-Reading"><span class="nav-text">Further Reading</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weihang Lo</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" href="https://hexo.io">Hexo</a></div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">Theme &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  

    
      <script id="dsq-count-scr" src="https://weihang-lo.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://weihanglo.github.io/2017/javascript-concurrency-async-function/';
          this.page.identifier = '2017/javascript-concurrency-async-function/';
          this.page.title = 'Modern Concurrency in JavaScript - Async Functions';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://weihang-lo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  










  





  

  

  

  

  

  

</body>
</html>
